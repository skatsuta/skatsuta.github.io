<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step by Step</title>
  
  <subtitle>1歩ずつ 確実に 進歩していこう</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skatsuta.github.io/"/>
  <updated>2018-03-13T08:06:37.811Z</updated>
  <id>https://skatsuta.github.io/</id>
  
  <author>
    <name>skatsuta</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 言語で学ぶ『暗号技術入門』Part 3 -CBC Mode-</title>
    <link href="https://skatsuta.github.io/2016/03/06/hyuki-crypt-book-go-3/"/>
    <id>https://skatsuta.github.io/2016/03/06/hyuki-crypt-book-go-3/</id>
    <published>2016-03-06T09:52:50.000Z</published>
    <updated>2018-03-13T08:06:37.811Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://amzn.to/1OyCzdb" target="_blank" rel="noopener">結城浩さんの『暗号技術入門』</a>を Go 言語を使って学ぶ記事の第3回です。<a href="http://skatsuta.github.io/2016/01/19/hyuki-crypt-book-go-2/">前回</a>は AES について解説しました。</p><p>今回は<strong>第4章「ブロック暗号のモード」</strong>です。そもそも、ブロック暗号の「モード」とは何なのでしょうか。</p><h1 id="ブロック暗号の「モード」とは"><a href="#ブロック暗号の「モード」とは" class="headerlink" title="ブロック暗号の「モード」とは"></a>ブロック暗号の「モード」とは</h1><p>前回の終わりにも書いたように、僕らが暗号化したい平文の長さは、たいていの場合ブロック暗号のブロック長 (AES なら 128 ビット) より長いことが多いです。そのため、ブロック暗号を<strong>繰り返し</strong>使って、長い文章全体を暗号化する必要があります。このブロック暗号を<strong>繰り返す方法</strong>のことをブロック暗号の<strong>「モード」</strong>と呼びます。</p><p>ブロック暗号のモードにはいくつもの種類がありますが、今回と次回でその中でも比較的使用が推奨されている <strong>CBC モード</strong>と<strong>CTR モード</strong>について説明します。今回は CBC モードについてです。</p><p>なお、この記事中の Go のソースコードのバージョンはすべて 1.6 です。</p><h2 id="Go-におけるブロック暗号モード"><a href="#Go-におけるブロック暗号モード" class="headerlink" title="Go におけるブロック暗号モード"></a>Go におけるブロック暗号モード</h2><p>Go ではブロック暗号のモードはすべて <code>crypto/cipher</code> パッケージに定義されている <code>BlockMode</code> という統一のインターフェースを介して利用するようになっています。 <code>CryptoBlocks()</code> で <code>src</code> のデータを <code>dst</code> に暗号化または復号します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> BlockMode <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// BlockSize returns the mode's block size.</span></span><br><span class="line">        BlockSize() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// CryptBlocks encrypts or decrypts a number of blocks. The length of</span></span><br><span class="line">        <span class="comment">// src must be a multiple of the block size. Dst and src may point to</span></span><br><span class="line">        <span class="comment">// the same memory.</span></span><br><span class="line">        CryptBlocks(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Block</code> インターフェースと違い、 <code>BlockMode</code> インターフェースには <code>CryptBlocks()</code> メソッド1つしかありません。これは、そもそも暗号化と復号で別のオブジェクトを用いる必要があるからです。たとえば、あとで見るように、 CBC モードでの暗号化には <code>NewCBCEncrypter()</code> によるオブジェクトを使って、復号には <code>NewCBCDecrypter()</code> によるオブジェクトを使って <code>CryptBlocks()</code> を呼ぶ必要があります。</p><h1 id="CBC-Cipher-Block-Chaining-モード"><a href="#CBC-Cipher-Block-Chaining-モード" class="headerlink" title="CBC (Cipher Block Chaining) モード"></a>CBC (Cipher Block Chaining) モード</h1><h2 id="CBC-モードとは"><a href="#CBC-モードとは" class="headerlink" title="CBC モードとは"></a>CBC モードとは</h2><p><strong>CBC (Cipher Block Chaining) モードは、1つ前の暗号文ブロックと平文ブロックの内容を混ぜ合わせてから暗号化をおこなう方法</strong>です。暗号文ブロックをチェーンのように連鎖させることが名前の由来になっています。</p><p>では CBC モードの具体的なアルゴリズムを見てみましょう。</p><h2 id="CBC-モードのアルゴリズム"><a href="#CBC-モードのアルゴリズム" class="headerlink" title="CBC モードのアルゴリズム"></a>CBC モードのアルゴリズム</h2><p>以下の図のように、 <strong>CBC モードでは1つ前の暗号文ブロックと平文ブロックの XOR をとってから暗号化をおこないます</strong>。 “block cipher encryption” の中身には、たとえば AES を用いるのであればその処理が入ります。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/601px-CBC_encryption.svg.png" alt="https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/CBC_encryption.svg/601px-CBC_encryption.svg.png"></p><p>ただし、最初の平文ブロックを暗号化するときには「1つ前の暗号文ブロック」が存在しません。そこで、その代わりに<strong>「初期化ベクトル (initialization vector; IV)」</strong>というランダムなビット列を用意し、それを用います。</p><p>最終的に、生成される暗号文ブロックをつなげたものが暗号化されたデータになります。</p><p>逆に、復号化は以下の図のようになります。 XOR の対称的な性質により、復号化したブロックと1つ前の暗号文ブロックの XOR を再びとれば、元の平文が得られます。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/601px-CBC_decryption.svg.png" alt="https://upload.wikimedia.org/wikipedia/commons/thumb/2/2a/CBC_decryption.svg/601px-CBC_decryption.svg.png"></p><h2 id="CBC-モードを使ってみる"><a href="#CBC-モードを使ってみる" class="headerlink" title="CBC モードを使ってみる"></a>CBC モードを使ってみる</h2><p>Go 言語を使い、実際に CBC モードで長い平文を暗号化してみます。ブロック暗号としては AES を使います。</p><p><a href="http://play.golang.org/p/_q54T5eDwe" target="_blank" rel="noopener">http://play.golang.org/p/_q54T5eDwe</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/aes"</span></span><br><span class="line"><span class="string">"crypto/cipher"</span></span><br><span class="line"><span class="string">"crypto/rand"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 平文。長さが 16 バイトの整数倍でない場合はパディングする必要がある</span></span><br><span class="line">plainText := []<span class="keyword">byte</span>(<span class="string">"secret text 9999"</span>)</span><br><span class="line"><span class="comment">// 暗号化データ。先頭に初期化ベクトル (IV) を入れるため、1ブロック分余計に確保する</span></span><br><span class="line">encrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aes.BlockSize+<span class="built_in">len</span>(plainText))</span><br><span class="line"></span><br><span class="line"><span class="comment">// IV は暗号文の先頭に入れておくことが多い</span></span><br><span class="line">iv := encrypted[:aes.BlockSize]</span><br><span class="line"><span class="comment">// IV としてランダムなビット列を生成する</span></span><br><span class="line"><span class="keyword">if</span> _, err := io.ReadFull(rand.Reader, iv); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ブロック暗号として AES を使う場合</span></span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"secret-key-12345"</span>)</span><br><span class="line">block, err := aes.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CBC モードで暗号化する</span></span><br><span class="line">mode := cipher.NewCBCEncrypter(block, iv)</span><br><span class="line">mode.CryptBlocks(encrypted[aes.BlockSize:], plainText)</span><br><span class="line">fmt.Printf(<span class="string">"encrypted: %x\n"</span>, encrypted)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 復号するには復号化用オブジェクトが別に必要</span></span><br><span class="line">mode = cipher.NewCBCDecrypter(block, iv)</span><br><span class="line">decrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>(plainText))</span><br><span class="line"><span class="comment">// 先頭の IV を除いた部分を復号する</span></span><br><span class="line">mode.CryptBlocks(decrypted, encrypted[aes.BlockSize:])</span><br><span class="line">fmt.Printf(<span class="string">"decrypted: %s\n"</span>, decrypted)</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// decrypted: secret text 9999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>標準ライブラリのみを用いて直接暗号化をおこなおうとすると、結構面倒なことがわかります。実際にはアプリケーションが使いやすいようなラッパー処理を書き、それを用いることになると思います。</p><h2 id="Go-での実装"><a href="#Go-での実装" class="headerlink" title="Go での実装"></a>Go での実装</h2><p>では標準ライブラリの <code>crypto/cipher</code> において、 CBC モードがどのように実装されているのか見てみましょう。</p><p>CBC モードを表すのは以下の <code>cbc</code> 構造体です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cbc <span class="keyword">struct</span> &#123;</span><br><span class="line">b         Block</span><br><span class="line">blockSize <span class="keyword">int</span></span><br><span class="line">iv        []<span class="keyword">byte</span></span><br><span class="line">tmp       []<span class="keyword">byte</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cbc</code> 構造体のコンストラクタは <code>newCBC()</code> です。書き換えの影響を受けないように、 <code>cbc.iv</code> には引数の <code>iv</code> を完全にコピーしたものが入れられます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCBC</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> *<span class="title">cbc</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;cbc&#123;</span><br><span class="line">b:         b,</span><br><span class="line">blockSize: b.BlockSize(),</span><br><span class="line">iv:        dup(iv),</span><br><span class="line">tmp:       <span class="built_in">make</span>([]<span class="keyword">byte</span>, b.BlockSize()),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cbc</code> 構造体は直接 <code>BlockMode</code> インターフェースを実装してわけではありません。実際はそのエイリアスの <code>cbcEncrypter</code> / <code>cbcDecrypter</code> 型が暗号化 / 復号処理を実装しています。同じ構造体に複数の別名型をつけ、それぞれで違うメソッドを実装するというのは、参考になる実装方法ですね。</p><p>暗号化用オブジェクトは <code>NewCBCEncrypter()</code> で生成します。この戻り値が <code>BlockMode</code> インターフェースを実装した <code>cbcEncrypter</code> オブジェクトになります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cbcEncrypter cbc</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining</span></span><br><span class="line"><span class="comment">// mode, using the given Block. The length of iv must be the same as the</span></span><br><span class="line"><span class="comment">// Block's block size.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCEncrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(iv) != b.BlockSize() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"cipher.NewCBCEncrypter: IV length must equal block size"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (*cbcEncrypter)(newCBC(b, iv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>では、 <code>cbcEncrypter</code> の <code>CryptBlocks()</code> メソッドの実装を見てみましょう。やっているのは先に説明したアルゴリズム通り、平文ブロック (<code>src[:x.BlockSize]</code>) と1つ前の暗号文ブロック (<code>iv</code>) の XOR をとり (<code>xorBytes()</code>)、それを暗号化する (<code>x.b.Encrypt()</code>) ことです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *cbcEncrypter)</span> <span class="title">CryptBlocks</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src)%x.blockSize != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/cipher: input not full blocks"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dst) &lt; <span class="built_in">len</span>(src) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/cipher: output smaller than input"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iv := x.iv</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(src) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Write the xor to dst, then encrypt in place.</span></span><br><span class="line">xorBytes(dst[:x.blockSize], src[:x.blockSize], iv)</span><br><span class="line">x.b.Encrypt(dst[:x.blockSize], dst[:x.blockSize])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Move to the next block with this block as the next iv.</span></span><br><span class="line">iv = dst[:x.blockSize]</span><br><span class="line">src = src[x.blockSize:]</span><br><span class="line">dst = dst[x.blockSize:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the iv for the next CryptBlocks call.</span></span><br><span class="line"><span class="built_in">copy</span>(x.iv, iv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一方、復号用オブジェクトは <code>NewCBCDecrypter()</code> で生成します。この戻り値が <code>BlockMode</code> インターフェースを実装した <code>cbcDecrypter</code> オブジェクトになります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cbcDecrypter cbc</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining</span></span><br><span class="line"><span class="comment">// mode, using the given Block. The length of iv must be the same as the</span></span><br><span class="line"><span class="comment">// Block's block size and must match the iv used to encrypt the data.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCBCDecrypter</span><span class="params">(b Block, iv []<span class="keyword">byte</span>)</span> <span class="title">BlockMode</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(iv) != b.BlockSize() &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"cipher.NewCBCDecrypter: IV length must equal block size"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (*cbcDecrypter)(newCBC(b, iv))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>続いて <code>cbcDecrypter</code> の <code>CryptBlocks()</code> メソッドの実装を見てみます。 <code>To avoid making a copy each time, we loop over the blocks BACKWARDS.</code> というコメントがある通り、復号処理は暗号文の末尾から逆順でおこなっているようです。しかしながら、「コピーを防ぐため」ということの意図はよくわかりませんでした。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *cbcDecrypter)</span> <span class="title">CryptBlocks</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src)%x.blockSize != <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/cipher: input not full blocks"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dst) &lt; <span class="built_in">len</span>(src) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/cipher: output smaller than input"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// For each block, we need to xor the decrypted data with the previous block's ciphertext (the iv).</span></span><br><span class="line"><span class="comment">// To avoid making a copy each time, we loop over the blocks BACKWARDS.</span></span><br><span class="line">end := <span class="built_in">len</span>(src)</span><br><span class="line">start := end - x.blockSize</span><br><span class="line">prev := start - x.blockSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy the last block of ciphertext in preparation as the new iv.</span></span><br><span class="line"><span class="built_in">copy</span>(x.tmp, src[start:end])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Loop over all but the first block.</span></span><br><span class="line"><span class="keyword">for</span> start &gt; <span class="number">0</span> &#123;</span><br><span class="line">x.b.Decrypt(dst[start:end], src[start:end])</span><br><span class="line">xorBytes(dst[start:end], dst[start:end], src[prev:start])</span><br><span class="line"></span><br><span class="line">end = start</span><br><span class="line">start = prev</span><br><span class="line">prev -= x.blockSize</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The first block is special because it uses the saved iv.</span></span><br><span class="line">x.b.Decrypt(dst[start:end], src[start:end])</span><br><span class="line">xorBytes(dst[start:end], dst[start:end], x.iv)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set the new iv to the first block we copied earlier.</span></span><br><span class="line">x.iv, x.tmp = x.tmp, x.iv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CBC モードについては以上です。次回はブロック暗号でよく使われるもう1つのモード、 CTR モードについて書く予定です。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://amzn.to/1OyCzdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;結城浩さんの『暗号技術入門』&lt;/a&gt;を Go 言語を使って学ぶ記事の第3回です。&lt;a href=&quot;http://skatsuta.github.i
      
    
    </summary>
    
    
      <category term="Go" scheme="https://skatsuta.github.io/tags/Go/"/>
    
      <category term="Cryptography" scheme="https://skatsuta.github.io/tags/Cryptography/"/>
    
      <category term="AES" scheme="https://skatsuta.github.io/tags/AES/"/>
    
      <category term="CBC Mode" scheme="https://skatsuta.github.io/tags/CBC-Mode/"/>
    
  </entry>
  
  <entry>
    <title>Go 言語で学ぶ『暗号技術入門』Part 2 -AES-</title>
    <link href="https://skatsuta.github.io/2016/01/19/hyuki-crypt-book-go-2/"/>
    <id>https://skatsuta.github.io/2016/01/19/hyuki-crypt-book-go-2/</id>
    <published>2016-01-19T09:49:58.000Z</published>
    <updated>2018-03-13T08:06:37.811Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://amzn.to/1OyCzdb" target="_blank" rel="noopener">結城浩さんの『暗号技術入門』</a>を Go 言語を使って学ぶ記事の第2回です。<a href="http://skatsuta.github.io/2016/01/02/hyuki-crypt-book-go-1/">前回</a>は DES と Triple DES について解説しました。</p><p>今回は引き続き<strong>第3章「対称暗号（共通鍵暗号）」</strong>より、新しい標準暗号アルゴリズムである <strong>AES (Advanced Encryption Standard)</strong> について解説します。</p><h1 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h1><h2 id="AES-とは"><a href="#AES-とは" class="headerlink" title="AES とは"></a>AES とは</h2><p><strong>AES (Advanced Encryption Standard)</strong> はアメリカ合衆国の標準化機関である NIST (National Institute of Standards and Technology) が2000年に選定した、DES に代わる新たな対称暗号アルゴリズムです。世界中から応募を受け付け、最終的に <strong>Rijndael (ラインダール)</strong> というアルゴリズムが AES として選ばれました。</p><p>現在では、対称暗号を使う場合には AES を用いることが推奨されています。 TLS においても、本文のデータそのものの暗号化には主に AES が使われています。有名な<strong>公開鍵暗号</strong>は、この対称暗号の鍵を安全に通信相手に送るために使われており、本文のデータを公開鍵暗号で直接暗号化することはありません。</p><h2 id="Rijndael-とは"><a href="#Rijndael-とは" class="headerlink" title="Rijndael とは"></a>Rijndael とは</h2><p><strong>Rijndael (ラインダール)</strong> はブロック長 128 ビットの対称暗号アルゴリズムです。鍵のビット長は AES の規格では 128, 192, 256 ビットの3種類あり、それぞれ AES-128, AES-192, AES-256 と呼ばれています。</p><h2 id="AES-を使ってみる"><a href="#AES-を使ってみる" class="headerlink" title="AES を使ってみる"></a>AES を使ってみる</h2><p>Go で実際に AES による暗号化/復号をおこなってみます。 AES 用のオブジェクトは <code>crypto/aes</code> パッケージの <code>NewCipher()</code> で生成します。戻り値は <code>cipher.Block</code> インターフェースで、この <code>Encrypt()</code>/<code>Decrypt()</code> メソッドはそれぞれ AES による暗号化と復号の処理を実装しています。</p><p><a href="http://play.golang.org/p/jUAHbYacE4" target="_blank" rel="noopener">http://play.golang.org/p/jUAHbYacE4</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/aes"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 鍵の長さは 16, 24, 32 バイトのどれかにしないとエラー</span></span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"aes-secret-key-1"</span>)</span><br><span class="line"><span class="comment">// cipher.Block を実装している AES 暗号化オブジェクトを生成する</span></span><br><span class="line">c, err := aes.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暗号化される平文の長さは 16 バイト (128 ビット)</span></span><br><span class="line">plainText := []<span class="keyword">byte</span>(<span class="string">"secret plain txt"</span>)</span><br><span class="line"><span class="comment">// 暗号化されたバイト列を格納するスライスを用意する</span></span><br><span class="line">encrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aes.BlockSize)</span><br><span class="line"><span class="comment">// AES で暗号化をおこなう</span></span><br><span class="line">c.Encrypt(encrypted, plainText)</span><br><span class="line"><span class="comment">// 結果は暗号化されている</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(encrypted))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// #^ϗ~:f9��˱�1�</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 復号する</span></span><br><span class="line">decrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, aes.BlockSize)</span><br><span class="line">c.Decrypt(decrypted, encrypted)</span><br><span class="line"><span class="comment">// 結果は元の平文が得られる</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(decrypted))</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// secret plain txt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES-のアルゴリズム"><a href="#AES-のアルゴリズム" class="headerlink" title="AES のアルゴリズム"></a>AES のアルゴリズム</h2><p>Rindael も DES と同じく1回の暗号化処理単位を<strong>「ラウンド」</strong>と呼びます。1ラウンドは以下の図のような4つの処理から成り立っています。</p><p><img src="http://flylib.com/books/4/269/1/html/2/images/0130355488/graphics/02fig09.gif" alt="http://flylib.com/books/4/269/1/html/2/images/0130355488/graphics/02fig09.gif"></p><ol><li><strong>SubBytes</strong>: 入力バイトごとに対応表に基いて別のバイトに変換する</li><li><strong>ShiftRows</strong>: 4バイト単位でまとめた行を左に規則的にシフトして混ぜこぜにする</li><li><strong>MixColumns</strong>: 4バイトの値をビット演算を用いて別の4バイトに変換する</li><li><strong>AddRoundKey</strong>: MixColumns の出力 (4バイト) とラウンド鍵 (4バイト) との XOR を取る</li></ol><p>以上のラウンドを10〜14回繰り返します。</p><p>復号処理はそれぞれの処理の逆処理を、上記手順と逆順でおこないます。すなわち、</p><ol><li><strong>AddRoundKey</strong> (XOR は逆処理も XOR)</li><li><strong>InvMixColumns</strong> (MixColumns の逆処理)</li><li><strong>InvShiftRows</strong> (ShiftRows の逆処理)</li><li><strong>InvSubBytes</strong> (SubBytes の逆処理)</li></ol><p>という手順を暗号化時と同じラウンド回数分おこなうことで復号します。</p><h2 id="Go-での実装"><a href="#Go-での実装" class="headerlink" title="Go での実装"></a>Go での実装</h2><p>AES を実装した <code>crypto.Block</code> インターフェースの実装は以下の <code>aesCipher</code> 構造体です。フィールドには暗号化用のラウンド鍵群 <code>enc</code> と復号化用のラウンド鍵群 <code>dec</code> を持っています。これらは AddRoundKey の処理で使われ、1ラウンドで4バイト使うのでスライスの要素は <code>uint32</code> になっています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A cipher is an instance of AES encryption using a particular key.</span></span><br><span class="line"><span class="keyword">type</span> aesCipher <span class="keyword">struct</span> &#123;</span><br><span class="line">enc []<span class="keyword">uint32</span></span><br><span class="line">dec []<span class="keyword">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewCipher()</code> コンストラクタは以下のようになっています。鍵の長さは 16, 24, 32 バイトのどれかでないとエラーになります。また、 <code>expandKey()</code> で与えられた鍵からラウンド鍵を生成しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCipher creates and returns a new cipher.Block.</span></span><br><span class="line"><span class="comment">// The key argument should be the AES key,</span></span><br><span class="line"><span class="comment">// either 16, 24, or 32 bytes to select</span></span><br><span class="line"><span class="comment">// AES-128, AES-192, or AES-256.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span> &#123;</span><br><span class="line">k := <span class="built_in">len</span>(key)</span><br><span class="line"><span class="keyword">switch</span> k &#123;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, KeySizeError(k)</span><br><span class="line"><span class="keyword">case</span> <span class="number">16</span>, <span class="number">24</span>, <span class="number">32</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := k + <span class="number">28</span></span><br><span class="line">c := &amp;aesCipher&#123;<span class="built_in">make</span>([]<span class="keyword">uint32</span>, n), <span class="built_in">make</span>([]<span class="keyword">uint32</span>, n)&#125;</span><br><span class="line">expandKey(key, c.enc, c.dec)</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ラウンド鍵を生成する <code>expandKey()</code> の処理を見てみましょう。実は Go における AES の処理は CPU アーキテクチャが AMD64 か否かで分岐しています。 AMD64 の場合には以下のように、アセンブリコードがある場合にはそちらを使用するようになっており、ソースコードには <code>asm_amd64.s</code> というアセンブリも一緒に含まれています。高速に AES の処理をおこなうための工夫でしょう。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build amd64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// defined in asm_$GOARCH.s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAsm</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">expandKeyAsm</span><span class="params">(nr <span class="keyword">int</span>, key *<span class="keyword">byte</span>, enc *<span class="keyword">uint32</span>, dec *<span class="keyword">uint32</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">useAsm</span> = <span class="title">hasAsm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">expandKey</span><span class="params">(key []<span class="keyword">byte</span>, enc, dec []<span class="keyword">uint32</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> useAsm &#123;</span><br><span class="line">rounds := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> <span class="built_in">len</span>(key) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">128</span> / <span class="number">8</span>:</span><br><span class="line">rounds = <span class="number">10</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">192</span> / <span class="number">8</span>:</span><br><span class="line">rounds = <span class="number">12</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">256</span> / <span class="number">8</span>:</span><br><span class="line">rounds = <span class="number">14</span></span><br><span class="line">&#125;</span><br><span class="line">expandKeyAsm(rounds, &amp;key[<span class="number">0</span>], &amp;enc[<span class="number">0</span>], &amp;dec[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">expandKeyGo(key, enc, dec)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先に「ラウンドの回数は10〜14回」と書きましたが、上記を見ると、鍵長が 128, 192, 256 ビットだとそれぞれ 10, 12, 14 回のラウンドをおこなうことがわかります。</p><p>一方 AMD64 以外の CPU アーキテクチャの場合には、以下のように通常の Go で記述された処理をおこないます。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// +build !amd64</span><br><span class="line"></span><br><span class="line">func expandKey(key []byte, enc, dec []uint32) &#123;</span><br><span class="line">expandKeyGo(key, enc, dec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>また、暗号化/復号をおこなう <code>Encrypt()</code>/<code>Decrypt()</code> メソッドの実装は以下のようになっています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *aesCipher)</span> <span class="title">Encrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src) &lt; BlockSize &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/aes: input not full block"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dst) &lt; BlockSize &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/aes: output not full block"</span>)</span><br><span class="line">&#125;</span><br><span class="line">encryptBlock(c.enc, dst, src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *aesCipher)</span> <span class="title">Decrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(src) &lt; BlockSize &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/aes: input not full block"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(dst) &lt; BlockSize &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">"crypto/aes: output not full block"</span>)</span><br><span class="line">&#125;</span><br><span class="line">decryptBlock(c.dec, dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>encryptBlock()</code>, <code>decryptBlock()</code> も <code>expandKey()</code> と同様に、 AMD 64 の場合はアセンブリコードを、そうでなければ Go のコードを使用するようになっています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build amd64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// defined in asm_$GOARCH.s</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasAsm</span><span class="params">()</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">encryptBlockAsm</span><span class="params">(nr <span class="keyword">int</span>, xk *<span class="keyword">uint32</span>, dst, src *<span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">decryptBlockAsm</span><span class="params">(nr <span class="keyword">int</span>, xk *<span class="keyword">uint32</span>, dst, src *<span class="keyword">byte</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">useAsm</span> = <span class="title">hasAsm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">encryptBlock</span><span class="params">(xk []<span class="keyword">uint32</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> useAsm &#123;</span><br><span class="line">encryptBlockAsm(<span class="built_in">len</span>(xk)/<span class="number">4</span><span class="number">-1</span>, &amp;xk[<span class="number">0</span>], &amp;dst[<span class="number">0</span>], &amp;src[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">encryptBlockGo(xk, dst, src)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptBlock</span><span class="params">(xk []<span class="keyword">uint32</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> useAsm &#123;</span><br><span class="line">decryptBlockAsm(<span class="built_in">len</span>(xk)/<span class="number">4</span><span class="number">-1</span>, &amp;xk[<span class="number">0</span>], &amp;dst[<span class="number">0</span>], &amp;src[<span class="number">0</span>])</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">decryptBlockGo(xk, dst, src)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AMD64 以外はそのまま Go のコードを呼びます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// +build !amd64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encryptBlock</span><span class="params">(xk []<span class="keyword">uint32</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">encryptBlockGo(xk, dst, src)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptBlock</span><span class="params">(xk []<span class="keyword">uint32</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">decryptBlockGo(xk, dst, src)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>encryptBlockGo()</code>, <code>decryptBlockGo()</code> の実装の詳細はここでは割愛します。</p><h1 id="ブロック暗号の「モード」"><a href="#ブロック暗号の「モード」" class="headerlink" title="ブロック暗号の「モード」"></a>ブロック暗号の「モード」</h1><p>これまで見てきた対称暗号はすべて<strong>「固定長」の平文（ブロック）</strong>を暗号化するアルゴリズムでした。 AES の場合なら1回の処理で暗号化するのは <strong>128 ビット (16 バイト)</strong> です。</p><p>しかし僕たちが普段暗号化したい文章は当然もっと長いので、このブロック暗号を繰り返し使って、長い文章全体を暗号化する必要があります。ブロック暗号を繰り返す方法のことをブロック暗号の<strong>「モード」</strong>と呼びます。ブロック暗号のモードにはいろいろな種類があります。</p><p>ということで次回は<strong>第4章「ブロック暗号のモード」</strong>の <strong>CBC モード</strong>と <strong>CTR モード</strong>について紹介したいと思います。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://amzn.to/1OyCzdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;結城浩さんの『暗号技術入門』&lt;/a&gt;を Go 言語を使って学ぶ記事の第2回です。&lt;a href=&quot;http://skatsuta.github.i
      
    
    </summary>
    
    
      <category term="Go" scheme="https://skatsuta.github.io/tags/Go/"/>
    
      <category term="Cryptography" scheme="https://skatsuta.github.io/tags/Cryptography/"/>
    
      <category term="AES" scheme="https://skatsuta.github.io/tags/AES/"/>
    
      <category term="Rijndael" scheme="https://skatsuta.github.io/tags/Rijndael/"/>
    
  </entry>
  
  <entry>
    <title>Go 言語で学ぶ『暗号技術入門』Part 1 -DES, Triple DES-</title>
    <link href="https://skatsuta.github.io/2016/01/02/hyuki-crypt-book-go-1/"/>
    <id>https://skatsuta.github.io/2016/01/02/hyuki-crypt-book-go-1/</id>
    <published>2016-01-02T14:00:42.000Z</published>
    <updated>2018-03-13T08:06:37.810Z</updated>
    
    <content type="html"><![CDATA[<p>最近<a href="http://amzn.to/1OyCzdb" target="_blank" rel="noopener">結城浩さんの『暗号技術入門』</a>を読みました。現代の暗号技術について非常にわかりやすく書かれており、とってもおすすめの書籍です。</p><p>そこで『暗号技術入門』を参考に、 Go 言語のライブラリを使い、各種暗号技術の実装や使い方について学んでみたいと思います。以下の Go のソースコードのバージョンはすべて 1.5.2 です。</p><p>まずは<strong>第3章「対称暗号（共通鍵暗号）」</strong>です。対称暗号は、<strong>「共通の鍵で暗号化と復号をおこなう暗号アルゴリズム」</strong>です。</p><h1 id="DES-Data-Encryption-Standard"><a href="#DES-Data-Encryption-Standard" class="headerlink" title="DES (Data Encryption Standard)"></a>DES (Data Encryption Standard)</h1><h2 id="DES-とは"><a href="#DES-とは" class="headerlink" title="DES とは"></a>DES とは</h2><p><strong>DES (Data Encryption Standard)</strong> は、1977年にアメリカ合衆国の連邦情報処理標準規格 (FIPS) に採用された対称暗号です。しかし現在ではブルートフォースアタックにより短時間で解読されてしまうため、暗号化に用いるべきではありません。</p><p>ただ後述する <strong>Triple DES</strong> は DES による処理を3回おこなう方式であり、これは TLS にも使われている未だ現役な暗号方式であるため、その基礎となる DES の処理を知っておくことは有益です。</p><p>DES は 64 ビットの平文を、 64 ビット(実際は 56 ビット) の鍵を使って 64 ビットの暗号文に暗号化するアルゴリズムです。あるまとまり単位で暗号化をおこなうアルゴリズムを<strong>「ブロック暗号」</strong>と呼び、 DES はブロック暗号の一種です。</p><h3 id="Go-におけるブロック暗号"><a href="#Go-におけるブロック暗号" class="headerlink" title="Go におけるブロック暗号"></a>Go におけるブロック暗号</h3><p>Go ではブロック暗号はすべて <code>crypto/cipher</code> パッケージに定義されている <code>cipher.Block</code> という統一のインターフェースを介して利用するようになっています。 <code>Encrypt()</code> で暗号化、 <code>Decrypt()</code> で復号をおこないます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cipher</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Block <span class="keyword">interface</span> &#123;</span><br><span class="line">        <span class="comment">// BlockSize returns the cipher's block size.</span></span><br><span class="line">        BlockSize() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Encrypt encrypts the first block in src into dst.</span></span><br><span class="line">        <span class="comment">// Dst and src may point at the same memory.</span></span><br><span class="line">        Encrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decrypt decrypts the first block in src into dst.</span></span><br><span class="line">        <span class="comment">// Dst and src may point at the same memory.</span></span><br><span class="line">        Decrypt(dst, src []<span class="keyword">byte</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このインターフェースにより、ライブラリを使う側は具体的なブロック暗号アルゴリズムの違いを意識する必要なく、統一的に扱えるようになっています。</p><h2 id="DES-を使ってみる"><a href="#DES-を使ってみる" class="headerlink" title="DES を使ってみる"></a>DES を使ってみる</h2><p>ではまず実際に DES で暗号化/復号をおこなってみます。 DES 用のオブジェクトは <code>crypto/des</code> パッケージの <code>NewCipher()</code> で生成します。戻り値は <code>cipher.Block</code> インターフェースで、この <code>Encrypt()</code>/<code>Decrypt()</code> メソッドはそれぞれ DES による暗号化と復号の処理を実装しています。</p><p><a href="http://play.golang.org/p/F7QBes1BFK" target="_blank" rel="noopener">http://play.golang.org/p/F7QBes1BFK</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/des"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 鍵の長さは 8 バイト (64 ビット) にしないとエラー</span></span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"priv-key"</span>)</span><br><span class="line"><span class="comment">// cipher.Block を実装している DES 暗号化オブジェクトを生成する</span></span><br><span class="line">c, err := des.NewCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 平文も暗号化されるのは 8 バイト (64 ビット)</span></span><br><span class="line">plainText := []<span class="keyword">byte</span>(<span class="string">"plaintxt"</span>)</span><br><span class="line"><span class="comment">// 暗号化されたバイト列を格納するスライスを用意する</span></span><br><span class="line">encrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, des.BlockSize)</span><br><span class="line"><span class="comment">// DES で暗号化をおこなう</span></span><br><span class="line">c.Encrypt(encrypted, plainText)</span><br><span class="line"><span class="comment">// 結果は暗号化されている</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(encrypted)) <span class="comment">//=&gt; ����A�</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 復号する</span></span><br><span class="line">decrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, des.BlockSize)</span><br><span class="line">c.Decrypt(decrypted, encrypted)</span><br><span class="line"><span class="comment">// 結果は元の平文が得られる</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(decrypted)) <span class="comment">//=&gt; plaintxt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DES-のアルゴリズム"><a href="#DES-のアルゴリズム" class="headerlink" title="DES のアルゴリズム"></a>DES のアルゴリズム</h2><p>DES のアルゴリズムの概略は以下の図のように表せます。まず <strong>64 ビット</strong> (実質使われるのはそのうちの 56 ビット) の鍵から、<strong>16 個の「サブ鍵」</strong>という鍵を生成します。そしてそのサブ鍵を使い、 64 ビットの平文を<strong>「ラウンド」</strong>という処理に <strong>16 回</strong>かけます。</p><p><img src="https://techwith2.files.wordpress.com/2010/07/desa.jpg" alt="https://techwith2.files.wordpress.com/2010/07/desa.jpg"></p><p>各ラウンドでは以下の図のようなことをおこないます。まず暗号化対象の 64 ビットデータを 左右 32 ビットずつに分割します。続いて、サブ鍵と右の 32 ビットをラウンド関数 $f$ にかけたものと左の 32 ビットの XOR を取ります。最後にその左右を交換します。ラウンド関数 $f$ には任意の関数を用いることが可能です。</p><p><img src="http://crunchmodo.com/wp-content/uploads/2013/03/Function-of-Rounds-in-DES.png" alt="http://crunchmodo.com/wp-content/uploads/2013/03/Function-of-Rounds-in-DES.png"></p><p>この処理をサブ鍵 16 個を順に使って繰り返して、最終的に出力されるバイト列が暗号化データになります。</p><p>復号処理はサブ鍵を逆順で使って同じ処理を繰り返せばよいだけになります。なぜなら XOR を 2 回かけると元に戻るという性質があるためです。</p><p>DES の鍵の長さは 64 ビット、すなわち取りうる鍵の数は高々 2<sup>64</sup> ≒ 1.8 × 10<sup>19</sup> 個なので、現代のコンピュータであればブルートフォースアタックにより短時間で解読することが可能になってしまっています（ラウンド関数は暗号解読者に知られているという前提で考えるべきなので）。</p><h2 id="Go-での実装"><a href="#Go-での実装" class="headerlink" title="Go での実装"></a>Go での実装</h2><p>DES を実装した <code>cipher.Block</code> インターフェースの実体は以下の <code>desCipher</code> 構造体です。フィールドには <code>subkeys [16]uint64</code> を持っています。1つの <code>uint64</code> が1回のラウンドで使用する 64 ビット (8 バイト) 鍵で、 DES はそれを 16 回繰り返すため 16 個のサブ鍵が必要になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// desCipher is an instance of DES encryption.</span></span><br><span class="line"><span class="keyword">type</span> desCipher <span class="keyword">struct</span> &#123;</span><br><span class="line">subkeys [<span class="number">16</span>]<span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewCipher()</code> コンストラクタは以下のようになっています。鍵の長さは 8 バイト (64 ビット) でないとエラーになります。また <code>c.generateSubkeys(key)</code> でメインの鍵からサブ鍵の配列を生成しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewCipher creates and returns a new cipher.Block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) != <span class="number">8</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, KeySizeError(<span class="built_in">len</span>(key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">new</span>(desCipher)</span><br><span class="line">c.generateSubkeys(key)</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暗号化/復号をおこなう <code>Encrypt()</code>/<code>Decrypt()</code> メソッドの実装は以下のようになっています。 DES の暗号化/復号処理はサブ鍵を使う順番が違うだけなので、内部では <code>cryptBlock()</code> という共通の関数を用いていることがわかります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *desCipher)</span> <span class="title">Encrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123; encryptBlock(c.subkeys[:], dst, src) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *desCipher)</span> <span class="title">Decrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123; decryptBlock(c.subkeys[:], dst, src) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Encrypt one block from src into dst, using the subkeys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encryptBlock</span><span class="params">(subkeys []<span class="keyword">uint64</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">cryptBlock(subkeys, dst, src, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decrypt one block from src into dst, using the subkeys.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decryptBlock</span><span class="params">(subkeys []<span class="keyword">uint64</span>, dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">cryptBlock(subkeys, dst, src, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暗号化/復号のメインの処理は以下の <code>cryptBlock()</code> でおこなわれます。 <code>decrypt</code> フラグが <code>false</code> であればサブ鍵が昇順で使われて暗号化され、 <code>true</code> であれば逆の降順で使われて復号されます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cryptBlock</span><span class="params">(subkeys []<span class="keyword">uint64</span>, dst, src []<span class="keyword">byte</span>, decrypt <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">b := binary.BigEndian.Uint64(src)</span><br><span class="line">b = permuteInitialBlock(b)</span><br><span class="line">left, right := <span class="keyword">uint32</span>(b&gt;&gt;<span class="number">32</span>), <span class="keyword">uint32</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subkey <span class="keyword">uint64</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> decrypt &#123;</span><br><span class="line">subkey = subkeys[<span class="number">15</span>-i]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">subkey = subkeys[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">left, right = right, left^feistel(right, subkey)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// switch left &amp; right and perform final permutation</span></span><br><span class="line">preOutput := (<span class="keyword">uint64</span>(right) &lt;&lt; <span class="number">32</span>) | <span class="keyword">uint64</span>(left)</span><br><span class="line">binary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ラウンド関数 $f$ の実装は <code>feistel()</code> という関数ですが今回は割愛します。</p><h1 id="Triple-DES-3DES"><a href="#Triple-DES-3DES" class="headerlink" title="Triple DES (3DES)"></a>Triple DES (3DES)</h1><h2 id="Triple-DES-とは"><a href="#Triple-DES-とは" class="headerlink" title="Triple DES とは"></a>Triple DES とは</h2><p><strong>Triple DES (3DES)</strong> は、 DES よりも強力になるよう、 DES を3段重ねにした暗号アルゴリズムです。 Triple DES は TLS でも使われています。ただし、 <strong>AES (Advanced Encryption Standard)</strong> がある今、あえて Triple DES を使う必然性は薄いです。</p><p>Triple DES の特徴は、暗号化を3回おこなうのではなく【暗号化 → <strong>復号化</strong> → 暗号化】という重ね方をするところです。これは、すべての鍵を等しくすれば単なる DES と同じように使えるように互換性が確保されているためです。</p><p><img src="http://www.idga.org/images/article_images/small/MilioneCryptF5.jpg" alt="http://www.idga.org/images/article_images/small/MilioneCryptF5.jpg"></p><p>3つの鍵のうち鍵1と鍵3を同じにしたものを <strong>DES-EDE2</strong> と呼び、 3つの鍵すべてを違うものにしたものを <strong>DES-EDE3</strong> と呼びます。 EDE は Encryption → Decryption → Encryption の略です。</p><p>DES の鍵長は 64 ビットなので、 DES-EDE2 であれば鍵の長さは 128 ビット、 DES-EDE3 なら 192 ビットになります。したがって暗号強度的には DES-EDE3 を用いるほうがよいです。</p><h2 id="Triple-DES-を使ってみる"><a href="#Triple-DES-を使ってみる" class="headerlink" title="Triple DES を使ってみる"></a>Triple DES を使ってみる</h2><p>Triple DES も DES と同じ <code>crypto/des</code> パッケージに入っています。 Triple DES 用のオブジェクトは <code>NewTripleDESCipher()</code> で生成します。渡す鍵の長さは 24 バイト (192 ビット) になります。この戻り値も <code>cipher.Block</code> インターフェースですので、 DES の場合と使い方は同じです。</p><p><a href="http://play.golang.org/p/UfXv32bO8e" target="_blank" rel="noopener">http://play.golang.org/p/UfXv32bO8e</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"crypto/des"</span></span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 鍵の長さは 24 バイトにしないとエラー</span></span><br><span class="line">key := []<span class="keyword">byte</span>(<span class="string">"this is 3des private key"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Triple DES 暗号化用オブジェクトを生成する</span></span><br><span class="line">c, err := des.NewTripleDESCipher(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 暗号化される平文の長さは 8 バイト</span></span><br><span class="line">plainText := []<span class="keyword">byte</span>(<span class="string">"plaintxt"</span>)</span><br><span class="line"><span class="comment">// 暗号化された byte 列を格納する slice を用意する</span></span><br><span class="line">encrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, des.BlockSize)</span><br><span class="line"><span class="comment">// Triple DES で暗号化をおこなう</span></span><br><span class="line">c.Encrypt(encrypted, plainText)</span><br><span class="line"><span class="comment">// 結果は暗号化されている</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>(encrypted)) <span class="comment">//=&gt; �Y����4�</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Triple DES で復号する</span></span><br><span class="line">decrypted := <span class="built_in">make</span>([]<span class="keyword">byte</span>, des.BlockSize)</span><br><span class="line">c.Decrypt(decrypted, encrypted)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(decrypted)) <span class="comment">//=&gt; plaintxt</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Go-での実装-1"><a href="#Go-での実装-1" class="headerlink" title="Go での実装"></a>Go での実装</h2><p>Triple DES を実装した <code>cipher.Block</code> インターフェースの実体は以下の <code>tripleDESCipher</code> 構造体です。フィールドには <code>desCipher</code> を3つ持っています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A tripleDESCipher is an instance of TripleDES encryption.</span></span><br><span class="line"><span class="keyword">type</span> tripleDESCipher <span class="keyword">struct</span> &#123;</span><br><span class="line">cipher1, cipher2, cipher3 desCipher</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NewTripleDESCipher()</code> コンストラクタは以下のようになっています。鍵の長さは 24 バイト (192 ビット) でないとエラーになります。 3 つの <code>desCipher</code> はそれぞれ、元の鍵の 8 バイト目まで、9 から 16 バイト目まで、 17 から 24 バイト目までを鍵にしてサブ鍵を生成します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTripleDESCipher creates and returns a new cipher.Block.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTripleDESCipher</span><span class="params">(key []<span class="keyword">byte</span>)</span> <span class="params">(cipher.Block, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(key) != <span class="number">24</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, KeySizeError(<span class="built_in">len</span>(key))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c := <span class="built_in">new</span>(tripleDESCipher)</span><br><span class="line">c.cipher1.generateSubkeys(key[:<span class="number">8</span>])</span><br><span class="line">c.cipher2.generateSubkeys(key[<span class="number">8</span>:<span class="number">16</span>])</span><br><span class="line">c.cipher3.generateSubkeys(key[<span class="number">16</span>:])</span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暗号化/復号をおこなう <code>Encrypt()</code>/<code>Decrypt()</code> メソッドの実装は以下のようになっています。 Triple DES のアルゴリズムそのままに、 <code>Encrypt()</code> では各 <code>desCipher</code> が順に【暗号化 → 復号化 → 暗号化】の処理をおこないます。一方 <code>Decrypt()</code> では逆に【復号化 → 暗号化 → 復号化】という順で処理をおこなっていますね。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tripleDESCipher)</span> <span class="title">Encrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">c.cipher1.Encrypt(dst, src)</span><br><span class="line">c.cipher2.Decrypt(dst, dst)</span><br><span class="line">c.cipher3.Encrypt(dst, dst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tripleDESCipher)</span> <span class="title">Decrypt</span><span class="params">(dst, src []<span class="keyword">byte</span>)</span></span> &#123;</span><br><span class="line">c.cipher3.Decrypt(dst, src)</span><br><span class="line">c.cipher2.Encrypt(dst, dst)</span><br><span class="line">c.cipher1.Decrypt(dst, dst)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>次回は <strong>AES (Advanced Encryption Standard)</strong> についての記事を書く予定です。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近&lt;a href=&quot;http://amzn.to/1OyCzdb&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;結城浩さんの『暗号技術入門』&lt;/a&gt;を読みました。現代の暗号技術について非常にわかりやすく書かれており、とってもおすすめの書籍です。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Go" scheme="https://skatsuta.github.io/tags/Go/"/>
    
      <category term="Cryptography" scheme="https://skatsuta.github.io/tags/Cryptography/"/>
    
      <category term="DES" scheme="https://skatsuta.github.io/tags/DES/"/>
    
      <category term="Triple DES" scheme="https://skatsuta.github.io/tags/Triple-DES/"/>
    
  </entry>
  
  <entry>
    <title>Go 言語の値レシーバとポインタレシーバ</title>
    <link href="https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/"/>
    <id>https://skatsuta.github.io/2015/12/29/value-receiver-pointer-receiver/</id>
    <published>2015-12-29T05:47:02.000Z</published>
    <updated>2018-03-13T08:06:37.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「レシーバ」とは"><a href="#「レシーバ」とは" class="headerlink" title="「レシーバ」とは"></a>「レシーバ」とは</h1><p><a href="http://golang.jp/go_faq#Is_Go_an_object-oriented_language" target="_blank" rel="noopener">Go 言語はある種のオブジェクト指向プログラミング (OOP) 言語であり</a>、 OOP 言語の慣例通り、メソッドを呼び出される対象のことを「レシーバ」と呼びます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  p := Person&#123;Name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">  p.Greet(<span class="string">"Hi"</span>)</span><br><span class="line">  ↑</span><br><span class="line">コイツ</span><br></pre></td></tr></table></figure><p>ちなみになぜ「レシーバ」と呼ぶのかというと、昔の OOP 言語の文脈ではメソッド呼び出しのことを「メッセージの送信」と言い、メソッドを呼び出される側は「メッセージの受信側」だからです。</p><h1 id="「値レシーバ」と「ポインタレシーバ」"><a href="#「値レシーバ」と「ポインタレシーバ」" class="headerlink" title="「値レシーバ」と「ポインタレシーバ」"></a>「値レシーバ」と「ポインタレシーバ」</h1><p>Go 言語では「値」と「ポインタ」が明示的に区別されているため、たとえばある構造体に対してメソッドを定義する場合でも、「値型」に対する定義なのか「ポインタ型」に対する定義なのかはっきりと区別しなければなりません。それぞれについて簡単に説明します。</p><h2 id="値レシーバ"><a href="#値レシーバ" class="headerlink" title="値レシーバ"></a>値レシーバ</h2><p>「値型」に対してメソッド定義されたものが「値レシーバ」です。 Go 言語では構造体は値なので、以下の例では <code>Person</code> という値型に対して <code>Greet()</code> というメソッドを定義しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 型に対してメソッドを定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">"Taro"</span>&#125; <span class="comment">// 値型の変数を用意する</span></span><br><span class="line">    p.Greet(<span class="string">"Hi"</span>)             <span class="comment">//=&gt; Hi, I'm Taro.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ポインタレシーバ"><a href="#ポインタレシーバ" class="headerlink" title="ポインタレシーバ"></a>ポインタレシーバ</h2><p>「ポインタ型」に対してメソッド定義されたものが「ポインタレシーバ」です。以下の例では <code>*Person</code> というポインタ型に対して <code>Shout()</code> というメソッドを定義しています。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *Person 型に対してメソッドを定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp := &amp;Person&#123;Name: <span class="string">"Taro"</span>&#125; <span class="comment">// ポインタ型の変数を用意する</span></span><br><span class="line">    pp.Shout(<span class="string">"OH MY GOD"</span>)       <span class="comment">//=&gt; OH MY GOD!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="コンパイラによるレシーバの暗黙的変換"><a href="#コンパイラによるレシーバの暗黙的変換" class="headerlink" title="コンパイラによるレシーバの暗黙的変換"></a>コンパイラによるレシーバの暗黙的変換</h1><p>しかし実際には、メソッド呼び出し時にこのあたりのことを意識しなくてもすみます。それは <a href="http://golang.jp/go_spec#Calls" target="_blank" rel="noopener">Go 言語仕様の「呼び出し」のセクションにある通り</a>、レシーバの【値型 ⇔ ポインタ型】間の変換はコンパイラが暗黙的におこなってくれるからです。それぞれ例を見てみましょう。</p><h2 id="値レシーバの場合"><a href="#値レシーバの場合" class="headerlink" title="値レシーバの場合"></a>値レシーバの場合</h2><p>値型に対してあるメソッドが定義されているときに、ポインタ型変数からそのメソッドを呼び出そうとすると、コンパイラが暗黙的に値型のメソッド呼び出しに変換してくれます。以下の例では、 値型 <code>Person</code> に <code>Greet()</code> が定義されていますが、 <code>*Person</code> 型変数 <code>pp</code> からでも問題なく呼び出せます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person 型に対してメソッドを定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp := &amp;Person&#123;Name: <span class="string">"Taro"</span>&#125; <span class="comment">// ポインタ型の変数を用意する</span></span><br><span class="line">    (*pp).Greet(<span class="string">"Hi"</span>)           <span class="comment">//=&gt; Hi, I'm Taro. | 当然呼び出せる</span></span><br><span class="line">    pp.Greet(<span class="string">"Hi"</span>)              <span class="comment">//=&gt; Hi, I'm Taro. | コンパイラが上のコードに変換してくれる</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>したがって、以下のように <code>nil</code> ポインタ変数から呼び出そうとすると <code>panic</code> を起こします。 <code>*nilp</code> が存在しないからです。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nilp *Person <span class="comment">// nil ポインタ変数だと...</span></span><br><span class="line">nilp.Greet(<span class="string">"Hi"</span>) <span class="comment">//=&gt; panic: runtime error: invalid memory address or nil pointer dereference</span></span><br></pre></td></tr></table></figure><p>これは <code>Greet()</code> の中で <code>p.Name</code> を使っていることとは関係なく発生します。</p><p>上記コードの Playground: <a href="http://play.golang.org/p/SZOv0hTicF" target="_blank" rel="noopener">http://play.golang.org/p/SZOv0hTicF</a></p><h2 id="ポインタレシーバの場合"><a href="#ポインタレシーバの場合" class="headerlink" title="ポインタレシーバの場合"></a>ポインタレシーバの場合</h2><p>一方、ポインタ型に対してあるメソッドが定義されているときに、値型変数からそのメソッドを呼び出そうとすると、コンパイラが暗黙的にポインタ型のメソッド呼び出しに変換してくれます。以下の例では、 ポインタ型 <code>*Person</code> に <code>Shout()</code> が定義されていますが、 <code>Person</code> 型変数 <code>p</code> からでも問題なく呼び出せます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *Person 型に対してメソッドを定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">"Taro"</span>&#125; <span class="comment">// 値型の変数を用意する</span></span><br><span class="line">    (&amp;p).Shout(<span class="string">"OH MY GOD"</span>)   <span class="comment">//=&gt; OH MY GOD!!! | 当然呼び出せる</span></span><br><span class="line">    p.Shout(<span class="string">"OH MY GOD"</span>)      <span class="comment">//=&gt; OH MY GOD!!! | コンパイラが上のコードに変換してくれる</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/Vs-LOJq_1d" target="_blank" rel="noopener">http://play.golang.org/p/Vs-LOJq_1d</a></p><p>さらに、ポインタレシーバのメソッドは <code>nil</code> ポインタ変数からでも呼び出しが可能です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nilp *Person        <span class="comment">// nil ポインタ変数でも...</span></span><br><span class="line">nilp.Shout(<span class="string">"OH MY GOD"</span>) <span class="comment">//=&gt; OH MY GOD!!! | ちゃんと呼び出せる</span></span><br></pre></td></tr></table></figure><p>ただし当然のことながら、<strong>メソッド内でフィールドを使っていたら参照先がないので <code>panic</code> になります</strong>。以下の例では、 <code>p.Name</code> を使っているメソッド <code>ShoutName</code> を <code>nil</code> ポインタ変数から呼び出すと、メソッド呼び出しそのものは正常におこなわれるものの、フィールド呼び出しがあるせいで <code>panic</code> になります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *Person 型に対してメソッドを定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">ShoutName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"I'm %s!!!\n"</span>, p.Name) <span class="comment">// p.Name フィールドを呼び出していると...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nilp *Person <span class="comment">// nil ポインタだと...</span></span><br><span class="line">    nilp.ShoutName() <span class="comment">//=&gt; panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/UzB32jpi2q" target="_blank" rel="noopener">http://play.golang.org/p/UzB32jpi2q</a></p><h1 id="メソッド定義とメソッド呼び出しの真実"><a href="#メソッド定義とメソッド呼び出しの真実" class="headerlink" title="メソッド定義とメソッド呼び出しの真実"></a>メソッド定義とメソッド呼び出しの真実</h1><h2 id="メソッド定義の真実"><a href="#メソッド定義の真実" class="headerlink" title="メソッド定義の真実"></a>メソッド定義の真実</h2><p>メソッド定義は本質的には関数定義と等価です。 Go 言語の場合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>というメソッド定義は、内部的には</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Person</span>.<span class="title">Greet</span><span class="params">(p Person, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>という<strong>「メソッド式 (method expression)」</strong>と呼ばれる関数として定義されます。これは値レシーバの場合で、同様にポインタレシーバの場合</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>は</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Person)</span>.<span class="title">Shout</span><span class="params">(pp *Person, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>という関数として定義されます。</p><h2 id="コンパイラのソースコードを確かめる"><a href="#コンパイラのソースコードを確かめる" class="headerlink" title="コンパイラのソースコードを確かめる"></a>コンパイラのソースコードを確かめる</h2><p>Go 1.5.2 のソースコードを基にこのことを確かめてみましょう。該当箇所は以下になります (コメントはすべて僕が追記したものです)。</p><p><a href="https://github.com/golang/go/blob/release-branch.go1.5/src/cmd/compile/internal/gc/dcl.go#L1325-L1350" target="_blank" rel="noopener">src/cmd/compile/internal/gc/dcl.go#L1325-L1350</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n: メソッドを表す AST ノード</span></span><br><span class="line"><span class="comment">// t: メソッドをもつ型を表す AST ノード</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">methodname1</span><span class="params">(n *Node, t *Node)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line">star := <span class="string">""</span></span><br><span class="line"><span class="keyword">if</span> t.Op == OIND &#123;</span><br><span class="line">star = <span class="string">"*"</span></span><br><span class="line">t = t.Left</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> t.Sym == <span class="literal">nil</span> || isblank(n) &#123;</span><br><span class="line"><span class="keyword">return</span> newfuncname(n.Sym)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p <span class="keyword">string</span></span><br><span class="line"><span class="keyword">if</span> star != <span class="string">""</span> &#123;</span><br><span class="line">p = fmt.Sprintf(<span class="string">"(%s%v).%v"</span>, star, t.Sym, n.Sym) <span class="comment">// (*Type).Method</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = fmt.Sprintf(<span class="string">"%v.%v"</span>, t.Sym, n.Sym)           <span class="comment">// Type.Method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> exportname(t.Sym.Name) &#123;</span><br><span class="line">n = newfuncname(Lookup(p))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">n = newfuncname(Pkglookup(p, t.Sym.Pkg))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの変数 <code>p</code> を見ていただくとわかる通り、メソッド定義においてメソッド名は <code>(*Type).Method</code> または <code>Type.Method</code> という名前をもつ、関数の AST ノードに変換されています。</p><h2 id="メソッド呼び出しの真実"><a href="#メソッド呼び出しの真実" class="headerlink" title="メソッド呼び出しの真実"></a>メソッド呼び出しの真実</h2><p>メソッド定義と同様に、メソッド呼び出しもメソッド式という関数の呼び出しの糖衣構文にすぎません。たとえば、以下の例では <code>p.Greet(...)</code> と <code>Person.Greet(p, ...)</code> 、 <code>pp.Shout(...)</code> と <code>(*Person).Shout(pp, ...)</code> はそれぞれ等価です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">    <span class="comment">// 以下は等価</span></span><br><span class="line">    p.Greet(<span class="string">"Hi"</span>)         <span class="comment">//=&gt; Hi, I'm Taro.</span></span><br><span class="line">    Person.Greet(p, <span class="string">"Hi"</span>) <span class="comment">//=&gt; Hi, I'm Taro.</span></span><br><span class="line"></span><br><span class="line">    pp := &amp;Person&#123;Name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">    <span class="comment">// 以下は等価</span></span><br><span class="line">    pp.Shout(<span class="string">"OH MY GOD"</span>)            <span class="comment">//=&gt; OH MY GOD!!!</span></span><br><span class="line">    (*Person).Shout(pp, <span class="string">"OH MY GOD"</span>) <span class="comment">//=&gt; OH MY GOD!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/3ENNQWghCX" target="_blank" rel="noopener">http://play.golang.org/p/3ENNQWghCX</a></p><p>ちなみに、メソッド式やメソッドは値としても扱えるので、以下のように変数に代入して利用することもできます。この場合、メソッド式 <code>f</code> にはレシーバ引数が必要で、メソッド値 <code>g</code> には必要ないことに注意してください。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;Name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">    f := Person.Greet</span><br><span class="line">    g := p.Greet</span><br><span class="line"></span><br><span class="line">    f(p, <span class="string">"Hello"</span>) <span class="comment">//=&gt; Hello, I'm Taro.</span></span><br><span class="line">    g(<span class="string">"Hello"</span>)    <span class="comment">//=&gt; Hello, I'm Taro.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/kpaGwzPu1u" target="_blank" rel="noopener">http://play.golang.org/p/kpaGwzPu1u</a></p><p>Go は関数が第一級オブジェクトなので便利ですね。</p><h1 id="メソッド定義で意識すべきこと"><a href="#メソッド定義で意識すべきこと" class="headerlink" title="メソッド定義で意識すべきこと"></a>メソッド定義で意識すべきこと</h1><p>改めて強調すると、メソッド定義において意識すべきなのは、<strong>レシーバが「第0引数」である</strong>ということです。たとえば、以下のメソッド定義</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; Name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pp *Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>は、内部的には</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Person</span>.<span class="title">Greet</span><span class="params">(p Person, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Person)</span>.<span class="title">Shout</span><span class="params">(pp *Person, msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>というメソッド式（関数）として定義されます。ただし直接このような関数名での関数定義はできません（コンパイラが <code>.</code> を含むシンボル名を許していないので）。</p><p>そして、メソッド呼び出しがメソッド式呼び出しと等価ということは、メソッド定義をする際には以下のことに気をつける必要があります。</p><h2 id="1-メソッド呼び出しごとにレシーバの値はコピーされる"><a href="#1-メソッド呼び出しごとにレシーバの値はコピーされる" class="headerlink" title="1. メソッド呼び出しごとにレシーバの値はコピーされる"></a>1. メソッド呼び出しごとにレシーバの値はコピーされる</h2><p>関数呼び出しごとに引数の値はスタックにコピーされますので、当然メソッド呼び出し時にはレシーバの値もコピーされます。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;Name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">Person.Greet(p, <span class="string">"Hi"</span>) <span class="comment">// p の値はコピーされてメソッド内で使われます</span></span><br><span class="line">p.Greet(<span class="string">"Hi"</span>)         <span class="comment">// p の値はコピーされてメソッド内で使われます</span></span><br></pre></td></tr></table></figure><p>したがって、特にデータ量の大きな構造体に値レシーバのメソッドを定義すると、メソッド呼び出しごとにコピーが発生するので非常に非効率であることがわかります。このことから、構造体におけるメソッド定義は原則ポインタレシーバに対しておこなったほうがよいです。</p><h2 id="2-値レシーバの値はメソッド内で書き換えても元のレシーバの値にはまったく影響がない"><a href="#2-値レシーバの値はメソッド内で書き換えても元のレシーバの値にはまったく影響がない" class="headerlink" title="2. 値レシーバの値はメソッド内で書き換えても元のレシーバの値にはまったく影響がない"></a>2. 値レシーバの値はメソッド内で書き換えても元のレシーバの値にはまったく影響がない</h2><p>値レシーバの場合、値そのものがまるっとコピーされるので、メソッド内でいくら値を書き換えても元のレシーバの値にはまったく影響がありません。</p><p>以下の例の場合、 <code>UnchangeName()</code> の処理は一見 setter っぽくレシーバの <code>name</code> を書き換えているように見えますが、 <code>p</code> が値レシーバなので <code>p.Greet()</code> で表示される名前は <code>Jiro</code> ではなく <code>Taro</code> のままになります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">Greet</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s, I'm %s.\n"</span>, msg, p.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span> <span class="title">UnchangeName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;name: <span class="string">"Taro"</span>&#125;</span><br><span class="line">    <span class="comment">// p の値はコピーされるので、フィールドを書き換えても影響ない</span></span><br><span class="line">    Person.UnchangeName(p, <span class="string">"Jiro"</span>)</span><br><span class="line">    p.UnchangeName(<span class="string">"Jiro"</span>)</span><br><span class="line"></span><br><span class="line">    p.Greet(<span class="string">"Hi"</span>) <span class="comment">//=&gt; Hi, I'm Taro.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/5kJVlx_XY7" target="_blank" rel="noopener">http://play.golang.org/p/5kJVlx_XY7</a></p><p>このことを利用すると、不変オブジェクトをつくることができます。その典型例が <code>time</code> パッケージの <code>Time</code> です。</p><h3 id="time-Time-は不変オブジェクト"><a href="#time-Time-は不変オブジェクト" class="headerlink" title="time.Time は不変オブジェクト"></a><code>time.Time</code> は不変オブジェクト</h3><p><a href="https://golang.org/pkg/time/" target="_blank" rel="noopener"><code>time.Time</code> の API 一覧</a>を見てもらうとわかる通り、 <code>Time</code> オブジェクトは</p><ul><li>フィールドがすべてプライベート</li><li>レシーバは Unmarshal 系を除きすべて <code>Time</code> 型（値型）</li><li>オブジェクトを返すメソッドの戻り値もすべて <code>Time</code> 型（値型）</li></ul><p>となっており、 <code>*Time</code> 型（ポインタ型）は基本的に現れません。</p><p>フィールドがプライベートなので直接の値の変更ができず、またレシーバも戻り値もほぼすべてポインタ型ではなく値型なので、一度生成された <code>Time</code> オブジェクトは一切変更する手段がないということになります。</p><p>Java では <code>java.util.Date</code> クラスや <code>java.util.Calendar</code> クラスが可変でスレッドセーフではないことが長年問題となっており、やっと Java 8 で不変オブジェクトを基本とする <code>java.time</code> パッケージが導入されました（<a href="http://www.oracle.com/technetwork/jp/articles/java/jf14-date-time-2125367-ja.html" target="_blank" rel="noopener">Java SE 8 Date and Time -新しい日付/時間ライブラリが必要になる理由-</a>）。 Go では少なくともこの種の問題は避けられているわけですね。</p><p>それでも Go ではエクスポートされたフィールドの直接書き換えや、オブジェクトの内部状態を書き換える副作用のあるメソッドが気軽に用いられる傾向にあります。並行処理に耐える不変オブジェクトを設計したい場合は、 <code>Time</code> を参考にした構造体設計にするとよいかもしれません。</p><h2 id="3-ポインタレシーバにするとメソッド内でレシーバの値を書き換えられる"><a href="#3-ポインタレシーバにするとメソッド内でレシーバの値を書き換えられる" class="headerlink" title="3. ポインタレシーバにするとメソッド内でレシーバの値を書き換えられる"></a>3. ポインタレシーバにするとメソッド内でレシーバの値を書き換えられる</h2><p>一方、レシーバをポインタレシーバにした場合、メソッド呼び出し時にコピーされるのもポインタになるので、そのポインタを使うことでレシーバの実際の値を書き換えることができます（ただし <code>map</code> や <code>chan</code> などの参照型をベースとする型は半分ポインタみたいなものなので、値レシーバでも可能ですが）。</p><p>たとえば以下の例の場合、 <code>ChangeName()</code> メソッドのレシーバは <code>*Person</code> なので、 <code>p.name</code> フィールドを書き換えることが可能であり、 <code>p.Greet()</code> で表示される名前は <code>Jiro</code> に変化します。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPerson</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Person</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Person&#123;name: name&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p の値を変更したいのでポインタレシーバで定義する</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">ChangeName</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := NewPerson(<span class="string">"Taro"</span>)</span><br><span class="line">    p.ChangeName(<span class="string">"Jiro"</span>)</span><br><span class="line"></span><br><span class="line">    p.Greet(<span class="string">"Hi"</span>) <span class="comment">//=&gt; Hi, I'm Jiro.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上記コードの Playground: <a href="http://play.golang.org/p/asH9DZRmxG" target="_blank" rel="noopener">http://play.golang.org/p/asH9DZRmxG</a></p><p>逆に言うと、レシーバの内部状態を変更したいメソッドは、（参照型を除き）<strong>必ずポインタレシーバで定義しなければなりません</strong>。</p><h2 id="4-ポインタレシーバのメソッド内でフィールドを呼び出す場合には、その前に-nil-チェックをすべき"><a href="#4-ポインタレシーバのメソッド内でフィールドを呼び出す場合には、その前に-nil-チェックをすべき" class="headerlink" title="4. ポインタレシーバのメソッド内でフィールドを呼び出す場合には、その前に nil チェックをすべき"></a>4. ポインタレシーバのメソッド内でフィールドを呼び出す場合には、その前に <code>nil</code> チェックをすべき</h2><p>ポインタレシーバのメソッドは <code>nil</code> ポインタ変数からでも呼び出しが可能なため、ポインタレシーバのメソッド内でフィールドを呼び出している場合、常に <code>nil pointer dereference</code> で <code>panic</code> になる危険性を孕んでいます。</p><p>以下の例の場合、 <code>ChangeNameUnsafe()</code> には <code>nil</code> チェックがないため <code>panic</code> になりますが、 <code>ChangeNameSafe()</code> のほうは <code>nil</code> チェックをしているため安全です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">ChangeNameUnsafe</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// これだけだと危険</span></span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">ChangeNameSafe</span><span class="params">(name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 他の言語だと this == nil みたいなものだから変な感じがするが、</span></span><br><span class="line">    <span class="comment">// きちんとガード句を設けておけば安全</span></span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    p.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pp *Person              <span class="comment">// nil ポインタ変数だと...</span></span><br><span class="line">    pp.ChangeNameUnsafe(<span class="string">"Jiro"</span>) <span class="comment">//=&gt; panic: runtime error: invalid memory address or nil pointer dereference</span></span><br><span class="line">    pp.ChangeNameSafe(<span class="string">"Jiro"</span>)   <span class="comment">// こちらは安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>レシーバは他の言語でいう <code>this</code> や <code>self</code> などに相当するため、メソッド内で <code>nil</code> チェックをすることには違和感があるかもしれません。しかし<strong>「レシーバは第0引数」</strong>であることを思い出せば、他のポインタ引数の <code>nil</code> チェックと同様に考えて、安全なプログラムを書くためにきちんとやったほうがよいです（僕もよく忘れますが）。</p><p>逆に考えると、 Java などと違いメソッド内でレシーバが <code>nil</code> か否かに応じたハンドリングができるので、それがきちんとなされていれば、メソッド呼び出し側が事前の <code>nil</code> チェックをする必要がないありがたさもあります。</p><h3 id="レシーバの値を使わない場合はレシーバ変数を記述しなくてもよい"><a href="#レシーバの値を使わない場合はレシーバ変数を記述しなくてもよい" class="headerlink" title="レシーバの値を使わない場合はレシーバ変数を記述しなくてもよい"></a>レシーバの値を使わない場合はレシーバ変数を記述しなくてもよい</h3><p>上記のことに関連して、実はメソッド定義におけるレシーバ変数は書かなくても問題なくコンパイルできるため、メソッド内でレシーバの値を使わない場合は書かないのも1つの手です。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123; name <span class="keyword">string</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// p の値を使わないときは書かない</span></span><br><span class="line"><span class="comment">//    ↓</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*Person)</span> <span class="title">Shout</span><span class="params">(msg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s!!!\n"</span>, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>そのような処理は本質的にはメソッドにする必要がなく、単なる関数のままでもよいため、このようなケースはあまり多くないとは思います。ただ、パッとシグニチャを見ただけでレシーバの値が使われていないことがわかるので、ドキュメントとしての価値もあると思います。</p><h1 id="まとめ：値レシーバとポインタレシーバの使い分け"><a href="#まとめ：値レシーバとポインタレシーバの使い分け" class="headerlink" title="まとめ：値レシーバとポインタレシーバの使い分け"></a>まとめ：値レシーバとポインタレシーバの使い分け</h1><p>最後に、値レシーバとポインタレシーバの使い分けについて整理しておきたいと思います。</p><h2 id="基本はポインタレシーバ"><a href="#基本はポインタレシーバ" class="headerlink" title="基本はポインタレシーバ"></a>基本はポインタレシーバ</h2><p>レシーバの値を変更したい場合は（参照型を除き）必ずポインタレシーバにしなければなりません。構造体も基本的にはポインタレシーバにしたほうがよいでしょう。</p><p>また、統一性の観点からも、ある型のメソッドのレシーバを1つでもポインタレシーバにした場合には、値の変更の有無にかかわらずすべてポインタレシーバにしたほうがよいと思います。</p><h2 id="値レシーバにしたほうがよい場合"><a href="#値レシーバにしたほうがよい場合" class="headerlink" title="値レシーバにしたほうがよい場合"></a>値レシーバにしたほうがよい場合</h2><p><strong>レシーバの値を変更する必要がなく</strong>、かつ以下のどれかに該当するときは値レシーバにしたほうがよいです。ただし参照型の場合は値の変更の有無は関係ありません。</p><h3 id="int-string-などのプリミティブ型をベースとする型"><a href="#int-string-などのプリミティブ型をベースとする型" class="headerlink" title="int, string などのプリミティブ型をベースとする型"></a><code>int</code>, <code>string</code> などのプリミティブ型をベースとする型</h3><p>プリミティブ型はコピーコストが小さいため、通常は値レシーバにします。</p><h3 id="map-chan-といった参照型をベースとする型"><a href="#map-chan-といった参照型をベースとする型" class="headerlink" title="map, chan といった参照型をベースとする型"></a><code>map</code>, <code>chan</code> といった参照型をベースとする型</h3><p>参照型は半分ポインタみたいなものなので、値レシーバのままでも保持する要素の値を変更できます。コピーコストも大きくないため、通常は値レシーバにします。</p><h3 id="不変型"><a href="#不変型" class="headerlink" title="不変型"></a>不変型</h3><p>先に例として出した <code>time.Time</code> のような不変型を定義したい場合には、すべて値レシーバとして定義するのも良い方法です。</p><h3 id="小さい構造体"><a href="#小さい構造体" class="headerlink" title="小さい構造体"></a>小さい構造体</h3><p>コピーコストの小さい構造体の場合には、値レシーバでメソッドを定義すると処理がスタックで完結するので、ヒープへのアロケート回数や GC の回数が減ることが期待できます。</p><p>ただし<strong>この使い分けは感覚的におこなうのではなく、本当に効率的になるのかきちんと計測した結果に基いておこなうべき</strong>です。 Go 言語ではベンチマークの計測や pprof などによる解析が容易におこなえるので、これらを活用するとよいでしょう。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;「レシーバ」とは&quot;&gt;&lt;a href=&quot;#「レシーバ」とは&quot; class=&quot;headerlink&quot; title=&quot;「レシーバ」とは&quot;&gt;&lt;/a&gt;「レシーバ」とは&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://golang.jp/go_faq#Is_Go_an_obje
      
    
    </summary>
    
    
      <category term="Go" scheme="https://skatsuta.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Docker Machine v0.5 の Driver Plugins の仕組み</title>
    <link href="https://skatsuta.github.io/2015/11/22/docker-machine-plugin/"/>
    <id>https://skatsuta.github.io/2015/11/22/docker-machine-plugin/</id>
    <published>2015-11-22T11:17:43.000Z</published>
    <updated>2018-03-13T08:06:37.809Z</updated>
    
    <content type="html"><![CDATA[<p>※この記事は <a href="./talks/docker-machine-plugin">Driver Plugins of Docker Machine</a> を基にブログとして書き起こしたものです。</p><h1 id="Docker-Machine-とは"><a href="#Docker-Machine-とは" class="headerlink" title="Docker Machine とは"></a>Docker Machine とは</h1><p><a href="https://www.docker.com/docker-machine" target="_blank" rel="noopener">Docker Machine</a> とは、 Docker ホストの管理ツールです。たとえば以下のようにして使います。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># VirtualBox VM でローカル環境に demo という名前のホストをつくる</span></span><br><span class="line">$ docker-machine create --driver virtualbox demo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 環境変数を設定する</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env demo)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ホスト一覧を表示する</span></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME   ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">demo   *        virtualbox   Running   tcp://192.168.99.100:2376</span><br><span class="line"></span><br><span class="line"><span class="comment"># docker images で demo 内の image 一覧を表示する</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS の image を取得する</span></span><br><span class="line">$ docker pull centos</span><br><span class="line">...</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再び demo 内の image 一覧を表示する</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">centos              latest              e9fa5d3a0d0e        4 weeks ago         172.3 MB</span><br></pre></td></tr></table></figure><p>このように簡単に Docker ホストを作成することができます。</p><h1 id="Docker-Machine-の特長"><a href="#Docker-Machine-の特長" class="headerlink" title="Docker Machine の特長"></a>Docker Machine の特長</h1><h2 id="複数のホストを簡単に管理できる"><a href="#複数のホストを簡単に管理できる" class="headerlink" title="複数のホストを簡単に管理できる"></a>複数のホストを簡単に管理できる</h2><p>Docker Machine は複数のホストを一括して管理できます。以下のように環境変数を切り替えることで、 Docker コマンドでの接続先を簡単に切り替えることができます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ホスト一覧を表示する</span></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">default   -        virtualbox   Running   tcp://192.168.99.121:2376</span><br><span class="line">demo      *        virtualbox   Running   tcp://192.168.99.118:2376</span><br><span class="line">dev       -        virtualbox   Stopped</span><br><span class="line"></span><br><span class="line"><span class="comment"># ホストを default に切り替える</span></span><br><span class="line">$ <span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env default)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># default が active になった</span></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">default   *        virtualbox   Running   tcp://192.168.99.121:2376</span><br><span class="line">demo      -        virtualbox   Running   tcp://192.168.99.118:2376</span><br><span class="line">dev       -        virtualbox   Stopped</span><br><span class="line"></span><br><span class="line"><span class="comment"># default にある image は ubuntu</span></span><br><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu              latest              e9ae3c220b23        4 days ago          187.9 MB</span><br></pre></td></tr></table></figure><h2 id="クラウドのホストも簡単に管理できる"><a href="#クラウドのホストも簡単に管理できる" class="headerlink" title="クラウドのホストも簡単に管理できる"></a>クラウドのホストも簡単に管理できる</h2><p>もう1つの大きな特長は、クラウドサービスのホストも簡単に作成できることです。たとえば、 Amazon EC2 上にホストを立てるには、以下のようにします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Amazon EC2 にホストをつくる。各環境変数には適切な値を設定しておく</span></span><br><span class="line">$ docker-machine create \</span><br><span class="line">--driver amazonec2 \</span><br><span class="line">--amazonec2-access-key <span class="variable">$AWS_ACCESS_KEY_ID</span> \</span><br><span class="line">--amazonec2-secret-key <span class="variable">$AWS_SECRET_ACCESS_KEY</span> \</span><br><span class="line">--amazonec2-vpc-id <span class="variable">$AWS_VPC_ID</span> \</span><br><span class="line">--amazonec2-region ap-northeast-1 \</span><br><span class="line">--amazonec2-zone c \</span><br><span class="line">stg</span><br><span class="line"></span><br><span class="line"><span class="comment"># つくった EC2 インスタンスがホスト一覧に追加される</span></span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME   ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">demo   *        virtualbox   Running   tcp://192.168.99.100:2376</span><br><span class="line">dev    -        virtualbox   Running   tcp://192.168.99.102:2376</span><br><span class="line">stg    -        amazonec2    Running   tcp://52.68.147.113:2376</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh サブコマンドでそのまま SSH ログインできる</span></span><br><span class="line">$ docker-machine ssh stg</span><br><span class="line">...</span><br><span class="line">ubuntu@stg:~$</span><br><span class="line"></span><br><span class="line"><span class="comment"># 削除も簡単</span></span><br><span class="line">$ docker-machine rm stg</span><br><span class="line">$ docker-machine ls</span><br><span class="line">NAME   ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">demo   *        virtualbox   Running   tcp://192.168.99.100:2376</span><br><span class="line">dev    -        virtualbox   Running   tcp://192.168.99.102:2376</span><br></pre></td></tr></table></figure><p>コマンド1発で EC2 のホストをプロビジョニングできるなんて、とても便利じゃないでしょうか。</p><h1 id="v0-5-の変更点"><a href="#v0-5-の変更点" class="headerlink" title="v0.5 の変更点"></a>v0.5 の変更点</h1><p>2015年11月3日に v0.5 がリリースされました。その中での最大の変更点が、 <strong>Driver Plugins</strong> という仕組みです。</p><h2 id="Driver-Plugins"><a href="#Driver-Plugins" class="headerlink" title="Driver Plugins"></a>Driver Plugins</h2><p>Docker Machine のプロビジョニングの処理では、ホストのタイプ (VirtualBox なのか EC2 なのかなど) によって、それぞれに対応したドライバが実際の処理をおこないます。 v0.4 までは、その各ドライバはすべて <code>docker-machine</code> バイナリに組み込まれていました。しかし v0.5 から、各ドライバが独立したバイナリとして配布されるようになりました。このことは、以下のようにすると確認できます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-machine 関連のバイナリ一覧</span></span><br><span class="line">$ ls /usr/<span class="built_in">local</span>/bin | grep docker-machine</span><br><span class="line">docker-machine</span><br><span class="line">docker-machine-driver-amazonec2</span><br><span class="line">docker-machine-driver-azure</span><br><span class="line">docker-machine-driver-digitalocean</span><br><span class="line">docker-machine-driver-exoscale</span><br><span class="line">docker-machine-driver-generic</span><br><span class="line">docker-machine-driver-google</span><br><span class="line">docker-machine-driver-hyperv</span><br><span class="line">docker-machine-driver-none</span><br><span class="line">docker-machine-driver-openstack</span><br><span class="line">docker-machine-driver-rackspace</span><br><span class="line">docker-machine-driver-softlayer</span><br><span class="line">docker-machine-driver-virtualbox</span><br><span class="line">docker-machine-driver-vmwarefusion</span><br><span class="line">docker-machine-driver-vmwarevcloudair</span><br><span class="line">docker-machine-driver-vmwarevsphere</span><br></pre></td></tr></table></figure><p>この仕組みが Driver Plugins です。このような仕組みになったことで、ドライバの追加や削除が簡単におこなえるというプラガブル性や、メインバイナリとドライババイナリの開発・配布が独立しておこなえるというモジュール性が高まりました。</p><p>しかし一方でバイナリ自体が独立したことで、内部の仕組みは大きく変化しました。 v0.5 からは、このドライバとの通信方法に <strong>RPC (Remote Procesure Call)</strong> を用いるようになっています。ちなみに本家 Docker のプラグイン機構では一足先にこれが採用されています。</p><h1 id="Driver-Plugin-の起動"><a href="#Driver-Plugin-の起動" class="headerlink" title="Driver Plugin の起動"></a>Driver Plugin の起動</h1><p>このことを確かめてみましょう。以下は OS X でおこなった場合ですので、 Docker デーモンは VirtualBox 上で動いているという前提です。</p><p><code>lsof</code> コマンドを使って、ポートを使用しているプロセスを見てみます。まず通常状態では、 TCP ポートを使用している “docker” の名前がつくプロセスはいません。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常はポートを使用している "docker" の名前がつくプロセスはいない</span></span><br><span class="line">$ lsof -nP -iTCP -sTCP:LISTEN | grep docker</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>続いて <code>docker-machine ls</code> コマンドを実行してみます。すると、これまでなかったプロセスが立ち上がっていることがわかります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker-machine ls コマンドを実行すると、各ホストに対応するプラグインが RPC サーバとして立ち上がる</span></span><br><span class="line">$ docker-machine ls &amp;; sleep 0.5 &amp;&amp; lsof -nP -iTCP -sTCP:LISTEN | grep docker</span><br><span class="line">[1] 65804</span><br><span class="line">docker-ma 65806 skatsuta    3u  IPv4 0xc8646a3a5297e9ef      0t0  TCP 127.0.0.1:53372 (LISTEN)</span><br><span class="line">docker-ma 65807 skatsuta    3u  IPv4 0xc8646a3a573eb4af      0t0  TCP 127.0.0.1:53376 (LISTEN)</span><br><span class="line">docker-ma 65808 skatsuta    3u  IPv4 0xc8646a3a4ad3ff4f      0t0  TCP 127.0.0.1:53380 (LISTEN)</span><br><span class="line"></span><br><span class="line">NAME      ACTIVE   DRIVER       STATE     URL                         SWARM</span><br><span class="line">default   -        virtualbox   Stopped</span><br><span class="line">demo      *        virtualbox   Running   tcp://192.168.99.100:2376</span><br><span class="line">dev       -        virtualbox   Running   tcp://192.168.99.102:2376</span><br><span class="line">[1]  + 65804 <span class="keyword">done</span>       docker-machine ls</span><br></pre></td></tr></table></figure><p>名前が切れていて <code>docker-ma</code> までしか表示されていませんが、実は3つの <code>docker-machine-driver-virtualbox</code> プロセスが起動しています。<br>これらは RPC サーバとして、メインプロセスからの RPC リクエストを受け付け、ホストのプロビジョニング処理をおこなっています。</p><p>ではプラグインを直接起動してみたらどうなるのでしょうか？ やってみると以下のようなエラーメッセージが表示され、起動に失敗してしまいます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine-driver-virtualbox</span><br><span class="line">This is a Docker Machine plugin binary.</span><br><span class="line">Plugin binaries are not intended to be invoked directly.</span><br><span class="line">Please use this plugin through the main <span class="string">'docker-machine'</span> binary.</span><br></pre></td></tr></table></figure><p>実は以下のようにすると起動できますが、このプロセスもすぐ終了してしまいます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ MACHINE_PLUGIN_TOKEN=42 docker-machine-driver-virtualbox</span><br><span class="line">127.0.0.1:59375</span><br><span class="line"><span class="comment"># この間1秒以内</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>さすがにこんな早さではメインプロセスと通信するのに十分な時間があるとは思えません。ということでこのことも含めて、 Docker Machine v0.5 の Driver Plugins の内部実装を追ってみることにしましょう。</p><p>ちなみに以下に記載するコード内に適宜日本語によるコメントを書いていますが、これらはすべて僕が追記したものであり、元のソースコードにはありません。本来のソースコードへのリンクも併せて記載しているので、ちゃんと確認したい方はそちらをご覧ください。</p><h1 id="RPC-Client"><a href="#RPC-Client" class="headerlink" title="RPC Client"></a>RPC Client</h1><p>まず RPC クライアント側、すなわちメインプロセス側の実装です。まず RPC クライアントの役割を担うのは、以下の <code>RpcClientDriver</code> という構造体です。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/rpc/client_driver.go#L19-L23" target="_blank" rel="noopener">libmachine/drivers/rpc/client_driver.go#L19-L23</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RpcClientDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">plugin          localbinary.DriverPlugin <span class="comment">// プラグイン管理オブジェクト</span></span><br><span class="line">heartbeatDoneCh <span class="keyword">chan</span> <span class="keyword">bool</span>                <span class="comment">// heartbeat 終了メッセージ送信チャンネル</span></span><br><span class="line">Client          *InternalClient          <span class="comment">// Go の標準ライブラリの RPC クライアントをラップしたもの</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この構造体がプラグインへの RPC リクエストを担当します。 Heartbeat の送信についてはあとで解説します。</p><h1 id="クライアント生成とプラグイン起動"><a href="#クライアント生成とプラグイン起動" class="headerlink" title="クライアント生成とプラグイン起動"></a>クライアント生成とプラグイン起動</h1><p><code>docker-machine</code> のコマンドを実行すると、もろもろの前処理 (フラグのパースやホスト名の確認など) をおこなったあと、ほとんどの場合以下の <code>NewRpcClientDriver()</code> が呼ばれ、 RPC クライアントの生成処理とプラグインの起動処理がおこなわれます。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/rpc/client_driver.go#L49-L112" target="_blank" rel="noopener">libmachine/drivers/rpc/client_driver.go#L49-L112</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rawDriverData: ドライバに関する設定情報が JSON にシリアライズされたもの</span></span><br><span class="line"><span class="comment">//    driverName: "virtualbox", "amazonec2" などのドライバ名文字列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRpcClientDriver</span><span class="params">(rawDriverData []<span class="keyword">byte</span>, driverName <span class="keyword">string</span>)</span> <span class="params">(*RpcClientDriver, error)</span></span> &#123;</span><br><span class="line">mcnName := <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// バイナリプラグイン管理オブジェクトを生成する</span></span><br><span class="line">p, err := localbinary.NewLocalBinaryPlugin(driverName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非同期にドライバプラグイン (RPC サーバ) を起動する</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err := p.Serve(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Is this best approach?</span></span><br><span class="line">log.Warn(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// プラグインへの接続情報を取得する</span></span><br><span class="line">addr, err := p.Address()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Error attempting to get plugin server address for RPC: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// プラグインへ接続する</span></span><br><span class="line">rpcclient, err := rpc.DialHTTP(<span class="string">"tcp"</span>, addr)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC クライアントオブジェクトを生成する</span></span><br><span class="line">c := &amp;RpcClientDriver&#123;</span><br><span class="line">Client:          NewInternalClient(rpcclient),</span><br><span class="line">heartbeatDoneCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定期的にプラグインへ heartbeat を送信する goroutine を生成する</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c *RpcClientDriver)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-c.heartbeatDoneCh:</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> err := c.Client.Call(<span class="string">"RpcServerDriver.Heartbeat"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="literal">nil</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Warnf(<span class="string">"Error attempting heartbeat call to plugin server: %s"</span>, err)</span><br><span class="line">c.Close()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(heartbeatInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(c)</span><br><span class="line"></span><br><span class="line"><span class="comment">// サーバのバージョンを確認する</span></span><br><span class="line"><span class="keyword">var</span> version <span class="keyword">int</span></span><br><span class="line"><span class="keyword">if</span> err := c.Client.Call(<span class="string">"RpcServerDriver.GetVersion"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, &amp;version); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">log.Debug(<span class="string">"Using API Version "</span>, version)</span><br><span class="line"></span><br><span class="line"><span class="comment">// プラグイン情報をクライアントに設定する</span></span><br><span class="line"><span class="keyword">if</span> err := c.SetConfigRaw(rawDriverData); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mcnName = c.GetMachineName()</span><br><span class="line">p.MachineName = mcnName</span><br><span class="line">c.Client.MachineName = mcnName</span><br><span class="line">c.plugin = p</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>まず注目してもらいたいのは、 プラグインの起動処理を別の goroutine がおこなっていることです。このようにすることで、時間のかかるプラグインの起動処理を本処理とは別におこなうことができます。<br>もう1つは、 途中で heartbeat を送信する goroutine を立ち上げていることです。この goroutine は <code>RpcServerDriver.Heartbeat</code> というリモートメソッド呼び出しにより、プラグイン側に heartbeat を送っています。このことの意味は、あとで RPC サーバ側の解説をするときに説明します。</p><p>では、プラグインの起動処理についてもう少し追ってみましょう。</p><h3 id="プラグインの起動"><a href="#プラグインの起動" class="headerlink" title="プラグインの起動"></a>プラグインの起動</h3><p>プラグインの起動処理を実際におこなうのは、以下の <code>LocalBinaryExecutor</code> という構造体です。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/plugin/localbinary/plugin.go#L73-L77" target="_blank" rel="noopener">libmachine/drivers/plugin/localbinary/plugin.go#L73-L77</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LocalBinaryExecutor <span class="keyword">struct</span> &#123;</span><br><span class="line">pluginStdout, pluginStderr io.ReadCloser</span><br><span class="line">DriverName                 <span class="keyword">string</span></span><br><span class="line">binaryPath                 <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>この構造体は、以下の <code>Start()</code> メソッドの中で <code>exec.Command()</code> と <code>cmd.Start()</code> を実行することで、プラグインのプロセスを起動します。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/plugin/localbinary/plugin.go#L105-L132" target="_blank" rel="noopener">libmachine/drivers/plugin/localbinary/plugin.go#L105-L132</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lbe *LocalBinaryExecutor)</span> <span class="title">Start</span><span class="params">()</span> <span class="params">(*bufio.Scanner, *bufio.Scanner, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">log.Debugf(<span class="string">"Launching plugin server for driver %s"</span>, lbe.DriverName)</span><br><span class="line"></span><br><span class="line"><span class="comment">// プラグインのプロセスを起動するための exec.Cmd を生成する</span></span><br><span class="line">cmd := exec.Command(lbe.binaryPath)</span><br><span class="line"></span><br><span class="line">lbe.pluginStdout, err = cmd.StdoutPipe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Error getting cmd stdout pipe: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lbe.pluginStderr, err = cmd.StderrPipe()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Error getting cmd stderr pipe: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outScanner := bufio.NewScanner(lbe.pluginStdout)</span><br><span class="line">errScanner := bufio.NewScanner(lbe.pluginStderr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 環境変数 $MACHINE_PLUGIN_TOKEN に 42 を設定する</span></span><br><span class="line">os.Setenv(PluginEnvKey, PluginEnvVal)</span><br><span class="line"></span><br><span class="line"><span class="comment">// プロセスを起動する</span></span><br><span class="line"><span class="keyword">if</span> err := cmd.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, fmt.Errorf(<span class="string">"Error starting plugin binary: %s"</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outScanner, errScanner, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">PluginEnvKey = <span class="string">"MACHINE_PLUGIN_TOKEN"</span></span><br><span class="line">PluginEnvVal = <span class="string">"42"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>また、途中で <code>os.Setenv()</code> により、 <code>MACHINE_PLUGIN_TOKEN=42</code> に設定しているのがわかります。これが先ほどプラグインプロセスを単体で立ち上げてみたときにおこなったことです。</p><h1 id="RPC-リクエストの送信"><a href="#RPC-リクエストの送信" class="headerlink" title="RPC リクエストの送信"></a>RPC リクエストの送信</h1><p>では RPC リクエストの送信処理はどうなっているのでしょうか。 <code>RpcClientDriver</code> のメソッドの大部分は、単なる <code>RpcServerDriver</code> へのリモート呼び出しになっています。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/rpc/client_driver.go#L256-L270" target="_blank" rel="noopener">libmachine/drivers/rpc/client_driver.go#L256-L278</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RpcClientDriver)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(<span class="string">"RpcServerDriver.Create"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RpcClientDriver)</span> <span class="title">Remove</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(<span class="string">"RpcServerDriver.Remove"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RpcClientDriver)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(<span class="string">"RpcServerDriver.Start"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *RpcClientDriver)</span> <span class="title">Stop</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Client.Call(<span class="string">"RpcServerDriver.Stop"</span>, <span class="keyword">struct</span>&#123;&#125;&#123;&#125;, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create()</code>, <code>Remove()</code>, <code>Start()</code>, <code>Stop()</code> などの代表的な処理は、全部 RPC サーバ側に丸投げしています。ということで、 RPC サーバ側の実装を見てみましょう。</p><h1 id="RPC-Server"><a href="#RPC-Server" class="headerlink" title="RPC Server"></a>RPC Server</h1><p>RPC サーバ側、すなわちプラグインプロセス側の実装を見てみます。</p><h1 id="プラグインバイナリの起動処理"><a href="#プラグインバイナリの起動処理" class="headerlink" title="プラグインバイナリの起動処理"></a>プラグインバイナリの起動処理</h1><p>まず先にプラグインプロセスが起動されたときに最初に実行される処理を追ってみましょう。例として <code>docker-machine-driver-virtualbox</code> のエントリポイントは以下のようになっています。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/cmd/machine-driver-virtualbox.go#L8-L10" target="_blank" rel="noopener">cmd/machine-driver-virtualbox.go#L8-L10</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// docker-machine-driver-virtualbox の main 関数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">plugin.RegisterDriver(virtualbox.NewDriver(<span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これだけです。では <code>RegisterDriver()</code> の実装はどうなっているのでしょうか。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/plugin/register_driver.go#L17-L56" target="_blank" rel="noopener">libmachine/drivers/plugin/register_driver.go#L17-L56</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// heartbeat の猶予時間</span></span><br><span class="line">heartbeatTimeout = <span class="number">500</span> * time.Millisecond</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterDriver</span><span class="params">(d drivers.Driver)</span></span> &#123;</span><br><span class="line"><span class="comment">// $MACHINE_PLUGIN_TOKEN != 42 の場合は終了する</span></span><br><span class="line"><span class="keyword">if</span> os.Getenv(localbinary.PluginEnvKey) != localbinary.PluginEnvVal &#123;</span><br><span class="line">fmt.Fprintln(os.Stderr, <span class="string">`This is a Docker Machine plugin binary.</span></span><br><span class="line"><span class="string">Plugin binaries are not intended to be invoked directly.</span></span><br><span class="line"><span class="string">Please use this plugin through the main 'docker-machine' binary.`</span>)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libmachine.SetDebug(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// RPC サーバオブジェクトを生成し、登録処理をおこなう</span></span><br><span class="line">rpcd := rpcdriver.NewRpcServerDriver(d)</span><br><span class="line">rpc.Register(rpcd)</span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line"><span class="comment">// ポート番号ランダムで TCP リスナを生成する</span></span><br><span class="line">listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:0"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Fprintf(os.Stderr, <span class="string">"Error loading RPC server: %s\n"</span>, err)</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">fmt.Println(listener.Addr())</span><br><span class="line"></span><br><span class="line"><span class="comment">// リクエストを待ち受ける</span></span><br><span class="line"><span class="keyword">go</span> http.Serve(listener, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-rpcd.CloseCh:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// heartbeat が送られてきてる間はプロセス継続</span></span><br><span class="line"><span class="keyword">case</span> &lt;-rpcd.HeartbeatCh:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="comment">// 500ms 以内の間隔で heartbeat が送られてこなければ終了する</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(heartbeatTimeout):</span><br><span class="line">os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>まず最初に、 <code>$MACHINE_PLUGIN_TOKEN != 42</code> の場合はエラーメッセージを表示して <code>os.Exit(1)</code> しています。これが特定の環境変数をつけないとプラグイン単体では起動できなかった理由です。意図しない起動のされ方がなされないように、このようなセーフティーネットが張られているようです。 <code>42</code> なのは<a href="https://ja.wikipedia.org/wiki/%E9%8A%80%E6%B2%B3%E3%83%92%E3%83%83%E3%83%81%E3%83%8F%E3%82%A4%E3%82%AF%E3%83%BB%E3%82%AC%E3%82%A4%E3%83%89" target="_blank" rel="noopener"> 『銀河ヒッチハイクガイド』</a> に由来しているのでしょうか。</p><p>続いて <code>net.Listen(&quot;tcp&quot;, &quot;127.0.0.1:0&quot;)</code> で利用可能な TCP ポートで listen することを宣言します。 <code>net.Listen()</code> が内部で呼んでいる <code>net.ListenTCP()</code> の仕様として、ポート番号 0 の場合には利用可能な TCP ポートのどれかが割り当てられることになっています。</p><p>最後にリクエストを待ち受ける goroutine を起動するとともに、 <code>for</code>-<code>select</code> で無限ループに入ります。ここで先ほどプラグインプロセスが即時終了してしまった理由がわかります。プラグインは <code>rpcd.HeartbeatCh</code> チャンネルにメッセージが送られ続けている間は起動していますが、 500ms 以上メッセージが送られてこないと強制終了してしまうようになっているのです。これにより、メインプロセスが予期せぬ終了をしてしまった場合でも、プラグインプロセスがゾンビ化することを防いでいます。</p><h2 id="RPC-サーバ"><a href="#RPC-サーバ" class="headerlink" title="RPC サーバ"></a>RPC サーバ</h2><p>では、 RPC リクエストに対する実際の処理を見てみましょう。 RPC リクエストを受け付けるのは以下の <code>RpcServerDriver</code> という構造体です。この構造体のメソッドが <code>RpcClientDriver</code> から呼び出されていましたね。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/rpc/server_driver.go" target="_blank" rel="noopener">libmachine/drivers/rpc/server_driver.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RpcServerDriver <span class="keyword">struct</span> &#123;</span><br><span class="line">ActualDriver drivers.Driver <span class="comment">// 実際の処理をおこなう Driver インターフェース</span></span><br><span class="line">CloseCh      <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">HeartbeatCh  <span class="keyword">chan</span> <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各メソッドは以下のようになっていて、実際のところは <code>ActualDriver</code> に処理を委譲していることがわかります。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServerDriver)</span> <span class="title">Create</span><span class="params">(_, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ActualDriver.Create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServerDriver)</span> <span class="title">Remove</span><span class="params">(_ *<span class="keyword">struct</span>&#123;&#125;, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ActualDriver.Remove()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServerDriver)</span> <span class="title">Start</span><span class="params">(_ *<span class="keyword">struct</span>&#123;&#125;, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ActualDriver.Start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *RpcServerDriver)</span> <span class="title">Stop</span><span class="params">(_ *<span class="keyword">struct</span>&#123;&#125;, _ *<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.ActualDriver.Stop()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ではこの <code>ActualDriver</code> の型である <code>drivers.Driver</code> について詳しく見てみましょう。</p><h1 id="Driver-interface"><a href="#Driver-interface" class="headerlink" title="Driver interface"></a><code>Driver</code> interface</h1><p><code>drivers.Driver</code> はインターフェースであり、ホストへの操作を実際におこなうオブジェクトが実装すべきメソッド群を規定しています。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/libmachine/drivers/drivers.go#L11-L73" target="_blank" rel="noopener">libmachine/drivers/drivers.go#L11-L73</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Driver defines how a host is created and controlled. Different types of</span></span><br><span class="line"><span class="comment">// driver represent different ways hosts can be created (e.g. different</span></span><br><span class="line"><span class="comment">// hypervisors, different cloud providers)</span></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Create a host using the driver's config</span></span><br><span class="line">Create() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// DriverName returns the name of the driver as it is registered</span></span><br><span class="line">DriverName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetCreateFlags returns the mcnflag.Flag slice representing the flags</span></span><br><span class="line"><span class="comment">// that can be set, their descriptions and defaults.</span></span><br><span class="line">GetCreateFlags() []mcnflag.Flag</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetIP returns an IP or hostname that this host is available at</span></span><br><span class="line"><span class="comment">// e.g. 1.2.3.4 or docker-host-d60b70a14d3a.cloudapp.net</span></span><br><span class="line">GetIP() (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetMachineName returns the name of the machine</span></span><br><span class="line">GetMachineName() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetSSHHostname returns hostname for use with ssh</span></span><br><span class="line">GetSSHHostname() (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetSSHKeyPath returns key path for use with ssh</span></span><br><span class="line">GetSSHKeyPath() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetSSHPort returns port for use with ssh</span></span><br><span class="line">GetSSHPort() (<span class="keyword">int</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetSSHUsername returns username for use with ssh</span></span><br><span class="line">GetSSHUsername() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GetURL returns a Docker compatible host URL for connecting to this host</span></span><br><span class="line"><span class="comment">// e.g. tcp://1.2.3.4:2376</span></span><br><span class="line">GetURL() (<span class="keyword">string</span>, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetState returns the state that the host is in (running, stopped, etc)</span></span><br><span class="line">GetState() (state.State, error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kill stops a host forcefully</span></span><br><span class="line">Kill() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// PreCreateCheck allows for pre-create operations to make sure a driver is ready for creation</span></span><br><span class="line">PreCreateCheck() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove a host</span></span><br><span class="line">Remove() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Restart a host. This may just call Stop(); Start() if the provider does not</span></span><br><span class="line"><span class="comment">// have any special restart behaviour.</span></span><br><span class="line">Restart() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetConfigFromFlags configures the driver with the object that was returned</span></span><br><span class="line"><span class="comment">// by RegisterCreateFlags</span></span><br><span class="line">SetConfigFromFlags(opts DriverOptions) error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start a host</span></span><br><span class="line">Start() error</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop a host gracefully</span></span><br><span class="line">Stop() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Create()</code>, <code>Start()</code>, <code>Stop()</code>, <code>Remove()</code> など、ホストの操作に必要なメソッドが並んでいます。そして、ホストが VirtualBox なのか Amazon EC2 なのかなどに応じて、各ホストに対する具体的な処理の実装が変わってくるわけです。では例として VirtualBox 用の <code>Driver</code> の実装を見てみることにしましょう。</p><h3 id="VirtualBox-用の-Driver-の実装"><a href="#VirtualBox-用の-Driver-の実装" class="headerlink" title="VirtualBox 用の Driver の実装"></a>VirtualBox 用の <code>Driver</code> の実装</h3><p><a href="https://github.com/docker/machine/blob/v0.5.0/drivers/virtualbox/virtualbox.go#L49-L61" target="_blank" rel="noopener">drivers/virtualbox/virtualbox.go#L49-L61</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> &#123;</span><br><span class="line">VBoxManager                <span class="comment">// vbm(), vbmOut(), vbmOutErr() をもつインターフェース</span></span><br><span class="line">*drivers.BaseDriver</span><br><span class="line">CPU                 <span class="keyword">int</span>    <span class="comment">// デフォルト 1</span></span><br><span class="line">Memory              <span class="keyword">int</span>    <span class="comment">// デフォルト 1024 MB</span></span><br><span class="line">DiskSize            <span class="keyword">int</span>    <span class="comment">// デフォルト 20000 MB</span></span><br><span class="line">Boot2DockerURL      <span class="keyword">string</span> <span class="comment">// Boot2Docker のダウンロード URL</span></span><br><span class="line">Boot2DockerImportVM <span class="keyword">string</span> <span class="comment">// Boot2Docker の ISO のパス</span></span><br><span class="line">...</span><br><span class="line">NoShare             <span class="keyword">bool</span>   <span class="comment">// 共有ディレクトリをつくるかどうか</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ここで重要なのは <code>VBoxManager</code> という埋め込みフィールドです。 <code>VBoxManager</code> はインターフェースになっていて、その実装は <code>VBoxCmdManager</code> に書かれています。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/drivers/virtualbox/vbm.go#L51-L80" target="_blank" rel="noopener">drivers/virtualbox/vbm.go#L51-L80</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *VBoxCmdManager)</span> <span class="title">vbmOutErr</span><span class="params">(args ...<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// `VBoxManage args...` コマンドを実行する</span></span><br><span class="line">cmd := exec.Command(vboxManageCmd, args...)</span><br><span class="line">log.Debugf(<span class="string">"COMMAND: %v %v"</span>, vboxManageCmd, strings.Join(args, <span class="string">" "</span>))</span><br><span class="line"><span class="keyword">var</span> stdout bytes.Buffer</span><br><span class="line"><span class="keyword">var</span> stderr bytes.Buffer</span><br><span class="line">cmd.Stdout = &amp;stdout</span><br><span class="line">cmd.Stderr = &amp;stderr</span><br><span class="line">err := cmd.Run()</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vboxManageCmd</code> は VirtualBox をインストールすると付属してくる <code>VBoxManage</code> という CLI のパスを指していて、これはコマンドラインから VirtualBox の VM を操作できるツールです。つまり、内部的には <code>VBoxManage</code> コマンドを呼び出してそちらに処理をおこなわせているということです。以下の <code>Driver.Create()</code> の実装を見ることで、どのように <code>VBoxManage</code> を呼び出しているのか見てみましょう。</p><h1 id="Driver-Create-の実装"><a href="#Driver-Create-の実装" class="headerlink" title="Driver.Create() の実装"></a><code>Driver.Create()</code> の実装</h1><p>一番泥臭さがわかりやすそうだったので、 VirtualBox の VM を立ち上げる処理をおこなう <code>Driver.Create()</code> の実装を詳しく追ってみます。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/drivers/virtualbox/virtualbox.go#L229-L417" target="_blank" rel="noopener">drivers/virtualbox/virtualbox.go#L229-L417</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span> <span class="title">Create</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// Boot2Docker の ISO を読み込む</span></span><br><span class="line">b2dutils := mcnutils.NewB2dUtils(d.StorePath)</span><br><span class="line"><span class="keyword">if</span> err := b2dutils.CopyIsoToMachineDir(d.Boot2DockerURL, d.MachineName); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPU レベルでの仮想化機能が有効化チェックする</span></span><br><span class="line"><span class="keyword">if</span> d.IsVTXDisabled() &#123;</span><br><span class="line"><span class="comment">// Let's log a warning to warn the user. When the vm is started, logs</span></span><br><span class="line"><span class="comment">// will be checked for an error anyway.</span></span><br><span class="line"><span class="comment">// We could fail right here but the method to check didn't prove being</span></span><br><span class="line"><span class="comment">// bulletproof.</span></span><br><span class="line">log.Warn(<span class="string">"This computer doesn't have VT-X/AMD-v enabled. Enabling it in the BIOS is mandatory."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Infof(<span class="string">"Creating VirtualBox VM..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// import b2d VM if requested</span></span><br><span class="line"><span class="keyword">if</span> d.Boot2DockerImportVM != <span class="string">""</span> &#123;</span><br><span class="line">name := d.Boot2DockerImportVM</span><br><span class="line"></span><br><span class="line"><span class="comment">// make sure vm is stopped</span></span><br><span class="line">_ = d.vbm(<span class="string">"controlvm"</span>, name, <span class="string">"poweroff"</span>)</span><br><span class="line"></span><br><span class="line">diskInfo, err := d.getVMDiskInfo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(diskInfo.Path); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"clonehd"</span>, diskInfo.Path, d.diskPath()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debugf(<span class="string">"Importing VM settings..."</span>)</span><br><span class="line">vmInfo, err := d.getVMInfo()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d.CPU = vmInfo.CPUs</span><br><span class="line">d.Memory = vmInfo.Memory</span><br><span class="line"></span><br><span class="line">log.Debugf(<span class="string">"Importing SSH key..."</span>)</span><br><span class="line">keyPath := filepath.Join(mcnutils.GetHomeDir(), <span class="string">".ssh"</span>, <span class="string">"id_boot2docker"</span>)</span><br><span class="line"><span class="keyword">if</span> err := mcnutils.CopyFile(keyPath, d.GetSSHKeyPath()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">log.Infof(<span class="string">"Creating SSH key..."</span>)</span><br><span class="line"><span class="keyword">if</span> err := ssh.GenerateSSHKey(d.GetSSHKeyPath()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debugf(<span class="string">"Creating disk image..."</span>)</span><br><span class="line"><span class="keyword">if</span> err := d.generateDiskImage(d.DiskSize); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `VBoxManage createvm` コマンドで VM を作成する</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"createvm"</span>,</span><br><span class="line"><span class="string">"--basefolder"</span>, d.ResolveStorePath(<span class="string">"."</span>),</span><br><span class="line"><span class="string">"--name"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--register"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Debugf(<span class="string">"VM CPUS: %d"</span>, d.CPU)</span><br><span class="line">log.Debugf(<span class="string">"VM Memory: %d"</span>, d.Memory)</span><br><span class="line"></span><br><span class="line">cpus := d.CPU</span><br><span class="line"><span class="keyword">if</span> cpus &lt; <span class="number">1</span> &#123;</span><br><span class="line">cpus = <span class="keyword">int</span>(runtime.NumCPU())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cpus &gt; <span class="number">32</span> &#123;</span><br><span class="line">cpus = <span class="number">32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `VBoxManage modifyvm` コマンドで VM に各種設定を反映させる</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"modifyvm"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--firmware"</span>, <span class="string">"bios"</span>,</span><br><span class="line"><span class="string">"--bioslogofadein"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--bioslogofadeout"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--bioslogodisplaytime"</span>, <span class="string">"0"</span>,</span><br><span class="line"><span class="string">"--biosbootmenu"</span>, <span class="string">"disabled"</span>,</span><br><span class="line"><span class="string">"--ostype"</span>, <span class="string">"Linux26_64"</span>,</span><br><span class="line"><span class="string">"--cpus"</span>, fmt.Sprintf(<span class="string">"%d"</span>, cpus),</span><br><span class="line"><span class="string">"--memory"</span>, fmt.Sprintf(<span class="string">"%d"</span>, d.Memory),</span><br><span class="line"><span class="string">"--acpi"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--ioapic"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--rtcuseutc"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--natdnshostresolver1"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--natdnsproxy1"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--cpuhotplug"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--pae"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--hpet"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--hwvirtex"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--nestedpaging"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--largepages"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--vtxvpid"</span>, <span class="string">"on"</span>,</span><br><span class="line"><span class="string">"--accelerate3d"</span>, <span class="string">"off"</span>,</span><br><span class="line"><span class="string">"--boot1"</span>, <span class="string">"dvd"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"modifyvm"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--nic1"</span>, <span class="string">"nat"</span>,</span><br><span class="line"><span class="string">"--nictype1"</span>, <span class="string">"82540EM"</span>,</span><br><span class="line"><span class="string">"--cableconnected1"</span>, <span class="string">"on"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := d.setupHostOnlyNetwork(d.MachineName); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `VBoxManage storagectl` コマンドでストレージコントローラを付加する</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"storagectl"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--name"</span>, <span class="string">"SATA"</span>,</span><br><span class="line"><span class="string">"--add"</span>, <span class="string">"sata"</span>,</span><br><span class="line"><span class="string">"--hostiocache"</span>, <span class="string">"on"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `VBoxManage storageattach` コマンドでストレージを VM にアタッチする</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"storageattach"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--storagectl"</span>, <span class="string">"SATA"</span>,</span><br><span class="line"><span class="string">"--port"</span>, <span class="string">"0"</span>,</span><br><span class="line"><span class="string">"--device"</span>, <span class="string">"0"</span>,</span><br><span class="line"><span class="string">"--type"</span>, <span class="string">"dvddrive"</span>,</span><br><span class="line"><span class="string">"--medium"</span>, d.ResolveStorePath(<span class="string">"boot2docker.iso"</span>)); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"storageattach"</span>, d.MachineName,</span><br><span class="line"><span class="string">"--storagectl"</span>, <span class="string">"SATA"</span>,</span><br><span class="line"><span class="string">"--port"</span>, <span class="string">"1"</span>,</span><br><span class="line"><span class="string">"--device"</span>, <span class="string">"0"</span>,</span><br><span class="line"><span class="string">"--type"</span>, <span class="string">"hdd"</span>,</span><br><span class="line"><span class="string">"--medium"</span>, d.diskPath()); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let VBoxService do nice magic automounting (when it's used)</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"guestproperty"</span>, <span class="string">"set"</span>, d.MachineName, <span class="string">"/VirtualBox/GuestAdd/SharedFolders/MountPrefix"</span>, <span class="string">"/"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"guestproperty"</span>, <span class="string">"set"</span>, d.MachineName, <span class="string">"/VirtualBox/GuestAdd/SharedFolders/MountDir"</span>, <span class="string">"/"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共有ディレクトリ名を設定する</span></span><br><span class="line"><span class="keyword">var</span> shareName, shareDir <span class="keyword">string</span> <span class="comment">// TODO configurable at some point</span></span><br><span class="line"><span class="keyword">switch</span> runtime.GOOS &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"windows"</span>:</span><br><span class="line">shareName = <span class="string">"c/Users"</span></span><br><span class="line">shareDir = <span class="string">"c:\\Users"</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">"darwin"</span>:</span><br><span class="line">shareName = <span class="string">"Users"</span></span><br><span class="line">shareDir = <span class="string">"/Users"</span></span><br><span class="line"><span class="comment">// TODO "linux"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共有ディレクトリをマウントする</span></span><br><span class="line"><span class="keyword">if</span> shareDir != <span class="string">""</span> &amp;&amp; !d.NoShare &#123;</span><br><span class="line">log.Debugf(<span class="string">"setting up shareDir"</span>)</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(shareDir); err != <span class="literal">nil</span> &amp;&amp; !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> !os.IsNotExist(err) &#123;</span><br><span class="line"><span class="keyword">if</span> shareName == <span class="string">""</span> &#123;</span><br><span class="line"><span class="comment">// parts of the VBox internal code are buggy with share names that start with "/"</span></span><br><span class="line">shareName = strings.TrimLeft(shareDir, <span class="string">"/"</span>)</span><br><span class="line"><span class="comment">// TODO do some basic Windows -&gt; MSYS path conversion</span></span><br><span class="line"><span class="comment">// ie, s!^([a-z]+):[/\\]+!\1/!; s!\\!/!g</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// woo, shareDir exists!  let's carry on!</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"sharedfolder"</span>, <span class="string">"add"</span>, d.MachineName, <span class="string">"--name"</span>, shareName, <span class="string">"--hostpath"</span>, shareDir, <span class="string">"--automount"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enable symlinks</span></span><br><span class="line"><span class="keyword">if</span> err := d.vbm(<span class="string">"setextradata"</span>, d.MachineName, <span class="string">"VBoxInternal2/SharedFoldersEnableSymlinksCreate/"</span>+shareName, <span class="string">"1"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Infof(<span class="string">"Starting VirtualBox VM..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> d.Start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このように <code>VBoxManage createvm</code> や <code>VBoxManage modifyvm</code> コマンドなどに必要なフラグをつけて呼び出すことで、 VirtualBox ホストのプロビジョニング処理をおこなっていることがわかります。ここでは解説しませんが、最後に呼び出している <code>Driver.Start()</code> の中では VM の起動やネットワークの設定などがおこなわれます。なかなか泥臭さが伝わってきますね。</p><h3 id="Amazon-EC2-用の-Driver-の実装"><a href="#Amazon-EC2-用の-Driver-の実装" class="headerlink" title="Amazon EC2 用の Driver の実装"></a>Amazon EC2 用の <code>Driver</code> の実装</h3><p>もう1つだけ、 Amazon EC2 用の <code>Driver</code> の実装も見てみましょう。</p><p><a href="https://github.com/docker/machine/blob/v0.5.0/drivers/amazonec2/amazonec2.go#L23-L69" target="_blank" rel="noopener">drivers/amazonec2/amazonec2.go#L23-L69</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Driver <span class="keyword">struct</span> &#123;</span><br><span class="line">*drivers.BaseDriver</span><br><span class="line">Id                  <span class="keyword">string</span></span><br><span class="line">AccessKey           <span class="keyword">string</span></span><br><span class="line">SecretKey           <span class="keyword">string</span></span><br><span class="line">SessionToken        <span class="keyword">string</span></span><br><span class="line">Region              <span class="keyword">string</span> <span class="comment">// default: us-east-1</span></span><br><span class="line">AMI                 <span class="keyword">string</span> <span class="comment">// default: ami-615cb725 (Ubuntu 14.04)</span></span><br><span class="line">SSHKeyID            <span class="keyword">int</span></span><br><span class="line">KeyName             <span class="keyword">string</span></span><br><span class="line">InstanceId          <span class="keyword">string</span></span><br><span class="line">InstanceType        <span class="keyword">string</span> <span class="comment">// default: t2.micro</span></span><br><span class="line">PrivateIPAddress    <span class="keyword">string</span></span><br><span class="line">SecurityGroupId     <span class="keyword">string</span></span><br><span class="line">SecurityGroupName   <span class="keyword">string</span></span><br><span class="line">ReservationId       <span class="keyword">string</span></span><br><span class="line">RootSize            <span class="keyword">int64</span></span><br><span class="line">IamInstanceProfile  <span class="keyword">string</span></span><br><span class="line">VpcId               <span class="keyword">string</span></span><br><span class="line">SubnetId            <span class="keyword">string</span></span><br><span class="line">Zone                <span class="keyword">string</span> <span class="comment">// default: a</span></span><br><span class="line">keyPath             <span class="keyword">string</span></span><br><span class="line">RequestSpotInstance <span class="keyword">bool</span></span><br><span class="line">SpotPrice           <span class="keyword">string</span></span><br><span class="line">PrivateIPOnly       <span class="keyword">bool</span></span><br><span class="line">UsePrivateIP        <span class="keyword">bool</span></span><br><span class="line">Monitoring          <span class="keyword">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>こちらの構造体では、 EC2 に必要な access key や secret key, region, AMI などの情報を保持していることがわかります。具体的なメソッドの実装は解説しませんが、基本的には AWS SDK for Go を介して対応する EC2 の API を呼び出しています。</p><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>僕が今回 Driver Plugins の仕組みを追ってみようと思ったのは、「コンパイル型の静的言語でプラグイン機構を実現するにはどうすればよいのか？」ということを考えていたからでした。スクリプト言語であればプラグイン機構は簡単に実現できるのですが、 Go のように単一バイナリになり、 DLL のような仕組みもない言語において、プラグイン機構を実現する仕組みがわからなかったのです。 RPC を使うというのが常套手段なのはのちのちわかったのですが、具体的な実装を追ってみて腑に落ちた感じです。 Docker Machine のコードは比較的読みやすいので、とても勉強になりました。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;※この記事は &lt;a href=&quot;./talks/docker-machine-plugin&quot;&gt;Driver Plugins of Docker Machine&lt;/a&gt; を基にブログとして書き起こしたものです。&lt;/p&gt;
&lt;h1 id=&quot;Docker-Machine-とは&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="VirtualBox" scheme="https://skatsuta.github.io/tags/VirtualBox/"/>
    
      <category term="Docker Machine" scheme="https://skatsuta.github.io/tags/Docker-Machine/"/>
    
      <category term="Docker" scheme="https://skatsuta.github.io/tags/Docker/"/>
    
      <category term="Driver Plugins" scheme="https://skatsuta.github.io/tags/Driver-Plugins/"/>
    
      <category term="Amazon EC2" scheme="https://skatsuta.github.io/tags/Amazon-EC2/"/>
    
  </entry>
  
  <entry>
    <title>Aerospike にキーの情報も格納するには</title>
    <link href="https://skatsuta.github.io/2015/10/20/aerospike-key/"/>
    <id>https://skatsuta.github.io/2015/10/20/aerospike-key/</id>
    <published>2015-10-20T05:29:16.000Z</published>
    <updated>2018-03-13T08:06:37.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="aql-コマンドでキーそのものも確認したい"><a href="#aql-コマンドでキーそのものも確認したい" class="headerlink" title="aql コマンドでキーそのものも確認したい"></a><code>aql</code> コマンドでキーそのものも確認したい</h2><p>分散型 KVS である <a href="http://www.aerospike.com" target="_blank" rel="noopener">Aerospike</a> では、 <code>aql</code> という SQL ライクにデータを確認・操作できるコマンドラインインターフェースが提供されています。使える機能はかなり限られているものの、 KVS にもかかわらずまるで RDB であるかのように扱えるので、データの確認には重宝しています。</p><p>たとえば、以下のように <code>INSERT</code> したり <code>SELECT</code> したりできます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">aql&gt; INSERT INTO test.testset (PK, a, b) VALUES (<span class="string">'xyz'</span>, <span class="string">'abc'</span>, 123)</span><br><span class="line">OK, 1 record affected.</span><br><span class="line"></span><br><span class="line">aql&gt; SELECT * FROM test.testset</span><br><span class="line">+-------+-----+</span><br><span class="line">| a     | b   |</span><br><span class="line">+-------+-----+</span><br><span class="line">| <span class="string">"abc"</span> | 123 |</span><br><span class="line">+-------+-----+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.058 secs)</span><br></pre></td></tr></table></figure><p>しかしながらここで注目してもらいたいのが、キーである <code>&#39;xyz&#39;</code> が表示されていないということです。</p><h2 id="Aerospike-は内部的にはキーそのものを使用していない"><a href="#Aerospike-は内部的にはキーそのものを使用していない" class="headerlink" title="Aerospike は内部的にはキーそのものを使用していない"></a>Aerospike は内部的にはキーそのものを使用していない</h2><p>Aerospike は内部的には、レコードを指定するのにキーそのものではなくそのハッシュ値を使用しています。 <a href="http://www.aerospike.com/docs/architecture/data-model.html" target="_blank" rel="noopener">Aerospikeのデータモデルの説明</a> から引用してみます。</p><blockquote><p>Key / Digest</p><p>In the application, each record will have a key associated with it. This key is what the application will use to read or write the record.</p><p>However, when the key is sent to the database, the key (together with the set information) is hashed into a 160-bit digest. Within the database, the digest is used address the record for all operations.</p><p>The key is used primarily in the application, while the digest is primarily used for addressing the record in the database.</p><p>The key maybe either an Integer, String, or Bytes value.n</p><p>キー / ダイジェスト</p><p>アプリケーションの中では、各レコードにはそれに対応するキーがあります。このキーはアプリケーションがレコードを読み出したり書き出したりするのに使うものです。</p><p>しかしながら、キーがデータベースに送られるときには、そのキー（とセットの情報）は 160 bit のダイジェストにハッシュ化されます。データベースの中では、すべての操作において、レコードを指定するのにはそのダイジェストが使用されます。</p><p>キーは主にアプリケーションの中で使用され、ダイジェストは主にデータベースの中でレコードを指定するのに使用されます。</p><p>キーは整数か文字列、バイト値のどれかです。</p></blockquote><p>このような事情のため、 <code>aql</code> ではそのままではキーが表示されないようです。</p><h2 id="Aerospike-にキーの情報も格納するには"><a href="#Aerospike-にキーの情報も格納するには" class="headerlink" title="Aerospike にキーの情報も格納するには"></a>Aerospike にキーの情報も格納するには</h2><p><code>aql</code> でキーも表示するようにするためには、まずそもそも Aerospike にキーそのものの情報も格納するようにしなければなりません。つまり、クライアントアプリケーションからデータを送る際に、キーの情報も保存するように明示的に指定する必要があります。どのクライアントライブラリにも <code>WritePolicy.sendKey</code> のようなフラグがあるはずなので、それを <code>true</code> に設定します。</p><p>たとえば、 Go 言語のサンプルアプリケーションの場合には、以下のようにします。</p><h5 id="main-go"><a href="#main-go" class="headerlink" title="main.go"></a>main.go</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">asc <span class="string">"github.com/aerospike/aerospike-client-go"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">panicOnErr</span><span class="params">(err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cl, err := asc.NewClient(<span class="string">"127.0.0.1"</span>, <span class="number">3000</span>)</span><br><span class="line">panicOnErr(err)</span><br><span class="line"></span><br><span class="line">key, err := asc.NewKey(<span class="string">"test"</span>, <span class="string">"testset"</span>, <span class="string">"xyz"</span>)</span><br><span class="line">panicOnErr(err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// define some bins with data</span></span><br><span class="line">bins := asc.BinMap&#123;</span><br><span class="line"><span class="string">"a"</span>: <span class="string">"abc"</span>,</span><br><span class="line"><span class="string">"b"</span>: <span class="number">123</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// write the bins</span></span><br><span class="line">wp := asc.NewWritePolicy(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">wp.SendKey = <span class="literal">true</span> <span class="comment">// ここでキーそのものも送信するように指定する！</span></span><br><span class="line">err = cl.Put(wp, key, bins)</span><br><span class="line">panicOnErr(err)</span><br><span class="line"></span><br><span class="line">rec, err := cl.Get(<span class="literal">nil</span>, key)</span><br><span class="line">panicOnErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%#v\n"</span>, *rec)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>このプログラムを実行してから、 <code>aql</code> で確認してみます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">aerospike.Record&#123;Key:(*aerospike.Key)(0xc8200da000), Node:(*aerospike.Node)(0xc8200ae000), Bins:aerospike.BinMap&#123;<span class="string">"a"</span>:<span class="string">"abc"</span>, <span class="string">"b"</span>:123&#125;, Generation:1, Expiration:432000&#125;</span><br><span class="line"></span><br><span class="line">$ aql</span><br><span class="line">aql&gt; SELECT * FROM test.testset</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">| key   | a     | b   |</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">| <span class="string">"xyz"</span> | <span class="string">"abc"</span> | 123 |</span><br><span class="line">+-------+-------+-----+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.055 secs)</span><br></pre></td></tr></table></figure><p>きちんとキーも表示されるようになりましたね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;aql-コマンドでキーそのものも確認したい&quot;&gt;&lt;a href=&quot;#aql-コマンドでキーそのものも確認したい&quot; class=&quot;headerlink&quot; title=&quot;aql コマンドでキーそのものも確認したい&quot;&gt;&lt;/a&gt;&lt;code&gt;aql&lt;/code&gt; コマンドでキ
      
    
    </summary>
    
    
      <category term="Aerospike" scheme="https://skatsuta.github.io/tags/Aerospike/"/>
    
      <category term="KVS" scheme="https://skatsuta.github.io/tags/KVS/"/>
    
      <category term="aql" scheme="https://skatsuta.github.io/tags/aql/"/>
    
  </entry>
  
  <entry>
    <title>OS X 10.11 で RubyGems の native extension のビルドに失敗したら</title>
    <link href="https://skatsuta.github.io/2015/10/03/fail-gem-install/"/>
    <id>https://skatsuta.github.io/2015/10/03/fail-gem-install/</id>
    <published>2015-10-03T12:36:09.000Z</published>
    <updated>2018-03-13T08:06:37.809Z</updated>
    
    <content type="html"><![CDATA[<p>OS X 10.11 El Capitan にアップグレードしたのですが、その後 native extension を利用する gem のインストールに失敗するようになりました。今後のために、エラーの内容と解決方法について残しておくことにします。</p><h2 id="Native-extension-のビルドに失敗する"><a href="#Native-extension-のビルドに失敗する" class="headerlink" title="Native extension のビルドに失敗する"></a>Native extension のビルドに失敗する</h2><p>たとえば sqlite3 の gem を入れようとしたところ、以下のようなエラーが発生して、 native extension のビルドに失敗しました。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">$ gem install sqlite3 -v <span class="string">'1.3.10'</span></span><br><span class="line">Building native extensions.  This could take a <span class="keyword">while</span>...</span><br><span class="line">ERROR:  Error installing sqlite3:</span><br><span class="line">        ERROR: Failed to build gem native extension.</span><br><span class="line"></span><br><span class="line">    /Users/skatsuta/.rbenv/versions/2.1.5/bin/ruby extconf.rb</span><br><span class="line">checking <span class="keyword">for</span> sqlite3.h... *** extconf.rb failed ***</span><br><span class="line">Could not create Makefile due to some reason, probably lack of necessary</span><br><span class="line">libraries and/or headers.  Check the mkmf.log file <span class="keyword">for</span> more details.  You may</span><br><span class="line">need configuration options.</span><br><span class="line"></span><br><span class="line">Provided configuration options:</span><br><span class="line">        --with-opt-dir</span><br><span class="line">        --without-opt-dir</span><br><span class="line">        --with-opt-include</span><br><span class="line">        --without-opt-include=<span class="variable">$&#123;opt-dir&#125;</span>/include</span><br><span class="line">        --with-opt-lib</span><br><span class="line">        --without-opt-lib=<span class="variable">$&#123;opt-dir&#125;</span>/lib</span><br><span class="line">        --with-make-prog</span><br><span class="line">        --without-make-prog</span><br><span class="line">        --srcdir=.</span><br><span class="line">        --curdir</span><br><span class="line">        --ruby=/Users/skatsuta/.rbenv/versions/2.1.5/bin/ruby</span><br><span class="line">        --with-sqlite3-dir</span><br><span class="line">        --without-sqlite3-dir</span><br><span class="line">        --with-sqlite3-include</span><br><span class="line">        --without-sqlite3-include=<span class="variable">$&#123;sqlite3-dir&#125;</span>/include</span><br><span class="line">        --with-sqlite3-lib</span><br><span class="line">        --without-sqlite3-lib=<span class="variable">$&#123;sqlite3-dir&#125;</span>/lib</span><br><span class="line">/Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:456:<span class="keyword">in</span> `try_do<span class="string">': The compiler failed to generate an executable file. (RuntimeError)</span></span><br><span class="line"><span class="string">You have to install development tools first.</span></span><br><span class="line"><span class="string">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:587:in `try_cpp'</span></span><br><span class="line">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:1120:<span class="keyword">in</span> `block <span class="keyword">in</span> find_header<span class="string">'</span></span><br><span class="line"><span class="string">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:918:in `block in checking_for'</span></span><br><span class="line">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:351:<span class="keyword">in</span> `block (2 levels) <span class="keyword">in</span> postpone<span class="string">'</span></span><br><span class="line"><span class="string">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:321:in `open'</span></span><br><span class="line">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:351:<span class="keyword">in</span> `block <span class="keyword">in</span> postpone<span class="string">'</span></span><br><span class="line"><span class="string">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:321:in `open'</span></span><br><span class="line">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:347:<span class="keyword">in</span> `postpone<span class="string">'</span></span><br><span class="line"><span class="string">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:917:in `checking_for'</span></span><br><span class="line">        from /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/2.1.0/mkmf.rb:1119:<span class="keyword">in</span> `find_header<span class="string">'</span></span><br><span class="line"><span class="string">        from extconf.rb:30:in `&lt;main&gt;'</span></span><br><span class="line"></span><br><span class="line">extconf failed, <span class="built_in">exit</span> code 1</span><br><span class="line"></span><br><span class="line">Gem files will remain installed <span class="keyword">in</span> /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/gems/sqlite3-1.3.10 <span class="keyword">for</span> inspection.</span><br><span class="line">Results logged to /Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/extensions/x86_64-darwin-14/2.1.0-static/sqlite3-1.3.10/gem_make.out</span><br></pre></td></tr></table></figure><p>どうやら Makefile の生成に失敗しているようです。 <code>Check the mkmf.log file for more details.</code> とあるので、 mkmf.log を探してみます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ find ~/.rbenv | grep sqlite | grep mkmf.log</span><br><span class="line">/Users/skatsuta/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/extensions/x86_64-darwin-14/2.1.0-static/sqlite3-1.3.10/mkmf.log</span><br></pre></td></tr></table></figure><p>ありました。こちらを見てみます。</p><h5 id="mkmf-log"><a href="#mkmf-log" class="headerlink" title="mkmf.log"></a>mkmf.log</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"clang -o conftest -I/Users/skatsuta/.rbenv/versions/2.1.5/include/ruby-2.1.0/x86_64-darwin14.0 -I/Users/skatsuta/.rbenv/versions/2.1.5/include/ruby-2.1.0/ruby/backward -I/Users/skatsuta/.rbenv/versions/2.1.5/include/ruby-2.1.0 -I. -I/Users/skatsuta/.rbenv/versions/2.1.5/include  -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -D_DARWIN_UNLIMITED_SELECT -D_REENTRANT    -O3 -Wno-error=shorten-64-to-32  -pipe conftest.c  -L. -L/Users/skatsuta/.rbenv/versions/2.1.5/lib -L. -L/Users/skatsuta/.rbenv/versions/2.1.5/lib  -fstack-protector     -lruby-static -framework CoreFoundation  -lpthread -lgmp -ldl -lobjc "</span></span><br><span class="line">ld: library not found <span class="keyword">for</span> -lgmp</span><br><span class="line">clang: error: linker <span class="built_in">command</span> failed with <span class="built_in">exit</span> code 1 (use -v to see invocation)</span><br><span class="line">checked program was:</span><br><span class="line">/* begin */</span><br><span class="line">1: <span class="comment">#include "ruby.h"</span></span><br><span class="line">2:</span><br><span class="line">3: int main(int argc, char **argv)</span><br><span class="line">4: &#123;</span><br><span class="line">5:   <span class="built_in">return</span> 0;</span><br><span class="line">6: &#125;</span><br><span class="line">/* end */</span><br></pre></td></tr></table></figure><p><code>ld: library not found for -lgmp</code> とあるので、 <code>gmp</code> というライブラリをリンカが見つけられていません。 GMP とは <a href="https://gmplib.org/" target="_blank" rel="noopener">GNU Multi-Precision Library</a> のことで、多倍長整数など任意の精度の算術ライブラリのようです (<a href="https://ja.wikipedia.org/wiki/GNU_Multi-Precision_Library" target="_blank" rel="noopener">Wikipedia</a>)。</p><p>しかしながら、 <code>gmp</code> は Homebrew ですでにインストールされており、 <code>/usr/local/lib</code> にも存在します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ brew list | grep gmp</span><br><span class="line">gmp</span><br><span class="line"></span><br><span class="line">$ find /usr/<span class="built_in">local</span>/lib | grep gmp</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmp.10.dylib</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmp.a</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmp.dylib</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmpxx.4.dylib</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmpxx.a</span><br><span class="line">/usr/<span class="built_in">local</span>/lib/libgmpxx.dylib</span><br></pre></td></tr></table></figure><p>ここから先の詳しい原因はわからないのですが、 El Capitan になってからデフォルトで Clang が認識するライブラリパスに <code>/usr/local/lib</code> が含まれなくなったのではないかと思っています。このあたりは新しいセキュリティ機能である System Integrity Protection (SIP; 別名 rootless) とも関連がありそうな気がします。</p><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>場当たり的でよいのであれば、先の <code>gem install</code> 時のエラーログにもある通り、 <code>--with-opt-lib</code> オプションで明示的に指定してやればよいです。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gem install sqlite3 -v <span class="string">'1.3.10'</span> -- --with-opt-lib=/usr/<span class="built_in">local</span>/lib</span><br></pre></td></tr></table></figure><p>ただしこの方法だと <code>gmp</code> を使う gem をインストールするたびに、毎回指定する必要あり面倒です。</p><p>永続的に効果のある解決方法は、 <code>$LIBRARY_PATH</code> 環境変数に <code>/usr/local/lib</code> を追加してやることです。これで以下のようにインストールに成功するようになります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> LIBRARY_PATH=/usr/<span class="built_in">local</span>/lib:<span class="variable">$LIBRARY_PATH</span></span><br><span class="line">$ gem install sqlite3 -v <span class="string">'1.3.10'</span></span><br><span class="line">Fetching: sqlite3-1.3.10.gem (100%)</span><br><span class="line">Building native extensions.  This could take a <span class="keyword">while</span>...</span><br><span class="line">Successfully installed sqlite3-1.3.10</span><br><span class="line">Parsing documentation <span class="keyword">for</span> sqlite3-1.3.10</span><br><span class="line">Installing ri documentation <span class="keyword">for</span> sqlite3-1.3.10</span><br><span class="line">Done installing documentation <span class="keyword">for</span> sqlite3 after 0 seconds</span><br><span class="line">1 gem installed</span><br></pre></td></tr></table></figure><p><code>export LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATH</code> は .bashrc や .zshrc に書いておくとよいでしょう。</p><p>El Capitan では SIP があることで、 <code>/usr/local</code> 以下を使う Homebrew でも</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chown -R $(whoami):admin /usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><p>というコマンドを実行して権限を変えないと正常に動作しなかったりするなど、いろいろなトラブルシューティングが必要になりそうですね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OS X 10.11 El Capitan にアップグレードしたのですが、その後 native extension を利用する gem のインストールに失敗するようになりました。今後のために、エラーの内容と解決方法について残しておくことにします。&lt;/p&gt;
&lt;h2 id=&quot;N
      
    
    </summary>
    
    
      <category term="Ruby" scheme="https://skatsuta.github.io/tags/Ruby/"/>
    
      <category term="RubyGems" scheme="https://skatsuta.github.io/tags/RubyGems/"/>
    
  </entry>
  
  <entry>
    <title>HTTPie で Docker Remote API にアクセスする方法</title>
    <link href="https://skatsuta.github.io/2015/08/17/httpie-docker-remote-api/"/>
    <id>https://skatsuta.github.io/2015/08/17/httpie-docker-remote-api/</id>
    <published>2015-08-17T05:22:10.000Z</published>
    <updated>2018-03-13T08:06:37.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-のアーキテクチャ"><a href="#Docker-のアーキテクチャ" class="headerlink" title="Docker のアーキテクチャ"></a>Docker のアーキテクチャ</h2><p><a href="https://docs.docker.com/introduction/understanding-docker/" target="_blank" rel="noopener">Docker はクライアントサーバモデルも採用しており</a>、サーバ側の API 仕様は <a href="https://docs.docker.com/reference/api/docker_remote_api/" target="_blank" rel="noopener">Docker Remote API</a> として公開されています。つまり、 Docker クライアント (Docker コマンド) はこの Remote API を叩いて Docker サーバ (Docker デーモン) に操作を依頼しているのであり、設定をすれば普通の HTTP 経由でも API へアクセスすることが可能になっています。</p><p>Docker デーモンはデフォルトでは Unix ソケットの <code>unix:///var/run/docker.sock</code> を listen しますが、 Windows や OS X で Boot2Docker や Docker Machine を使っている場合には、 TCP ソケット (2376 番ポート) を listen するように設定されています。また、接続は TLS で暗号化されています。この辺りのことをクライアントからのアクセスの際に指定するために、以下の環境変数の設定が必要となるわけです。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Docker Machine の場合</span></span><br><span class="line">$ docker-machine env dev</span><br><span class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.100:2376"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/Users/skatsuta/.docker/machine/machines/dev"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"dev"</span></span><br><span class="line"><span class="comment"># Run this command to configure your shell:</span></span><br><span class="line"><span class="comment"># eval "$(docker-machine env dev)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boot2Docker なら `boot2docker shellinit`</span></span><br></pre></td></tr></table></figure><h2 id="HTTPie-で-Docker-Remote-API-にアクセスする"><a href="#HTTPie-で-Docker-Remote-API-にアクセスする" class="headerlink" title="HTTPie で Docker Remote API にアクセスする"></a>HTTPie で Docker Remote API にアクセスする</h2><p>たとえばイメージ一覧を取得してみます。現状のイメージ一覧は以下のようになっているとしましょう。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">golang              latest              124e2127157f        4 weeks ago         517.3 MB</span><br><span class="line">centos              latest              7322fbe74aa5        8 weeks ago         172.2 MB</span><br></pre></td></tr></table></figure><p>では Docker Remote API に直接アクセスしてみます。 <code>wget</code> を使った方法は<a href="http://nobusue.hatenablog.com/entry/2014/12/03/024226" target="_blank" rel="noopener">こちらの記事</a>で紹介されていますが、僕は <a href="https://github.com/jkbrzt/httpie" target="_blank" rel="noopener">HTTPie</a> を愛用しているので、今回はそちらを使ってやってみたいと思います。</p><p>結論から言えば、以下のようにオプションを指定して API にアクセスします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 簡略化のため、あらかじめホスト VM の IP アドレスを取得しておく</span></span><br><span class="line">$ <span class="built_in">export</span> DOCKER_IP=`docker-machine ip dev`</span><br><span class="line"></span><br><span class="line"><span class="comment"># HTTPie で TLS 接続でイメージ一覧を取得する</span></span><br><span class="line">$ http --verify=no --cert=<span class="variable">$DOCKER_CERT_PATH</span>/cert.pem --cert-key=<span class="variable">$DOCKER_CERT_PATH</span>/key.pem https://<span class="variable">$DOCKER_IP</span>:2376/images/json</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Length: 533</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Date: Mon, 17 Aug 2015 06:23:18 GMT</span><br><span class="line">Server: Docker/1.8.1 (linux)</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Created"</span>: 1436855204,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"124e2127157f398735e5888601e8b02cf832e037ef951317bc0a4f6256723d7b"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"ParentId"</span>: <span class="string">"69c177f0c117c1ea8c4593b4fbfa7affb4096f7abc751c9d818721bfdea087bb"</span>,</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [],</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"golang:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"Size"</span>: 2481,</span><br><span class="line">        <span class="string">"VirtualSize"</span>: 517283915</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Created"</span>: 1434648509,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"7322fbe74aa5632b33a400959867c8ac4290e9c5112877a7754be70cfe5d66e9"</span>,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"ParentId"</span>: <span class="string">"c852f6d61e65cddf1e8af1f6cd7db78543bfb83cdcd36845541cf6d9dfef20a0"</span>,</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [],</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"centos:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"Size"</span>: 0,</span><br><span class="line">        <span class="string">"VirtualSize"</span>: 172237380</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>詳細なイメージ情報が JSON で取得できました。この API 情報を使うことで、サードパーティでもさまざまな Docker 用ツールが開発できそうです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Docker-のアーキテクチャ&quot;&gt;&lt;a href=&quot;#Docker-のアーキテクチャ&quot; class=&quot;headerlink&quot; title=&quot;Docker のアーキテクチャ&quot;&gt;&lt;/a&gt;Docker のアーキテクチャ&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://d
      
    
    </summary>
    
    
      <category term="Docker" scheme="https://skatsuta.github.io/tags/Docker/"/>
    
      <category term="Docker Remote API" scheme="https://skatsuta.github.io/tags/Docker-Remote-API/"/>
    
      <category term="HTTPie" scheme="https://skatsuta.github.io/tags/HTTPie/"/>
    
  </entry>
  
  <entry>
    <title>Docker Machine で管理している VirtualBox の VM をローカルにポートフォワーディングする</title>
    <link href="https://skatsuta.github.io/2015/08/13/docker-machine-port-forwarding/"/>
    <id>https://skatsuta.github.io/2015/08/13/docker-machine-port-forwarding/</id>
    <published>2015-08-13T09:44:29.000Z</published>
    <updated>2018-03-13T08:06:37.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VirtulaBox-の-VM-からローカルへのポートフォワーディング"><a href="#VirtulaBox-の-VM-からローカルへのポートフォワーディング" class="headerlink" title="VirtulaBox の VM からローカルへのポートフォワーディング"></a>VirtulaBox の VM からローカルへのポートフォワーディング</h2><p>Linux 以外の OS 上で Docker を利用する場合、 VirtualBox などで Linux のホスト VM を立てる必要があります。このとき、ホスト VM からローカルへポートフォワーディングしたいと思うときがあります。これをおこなうには、 VirtualBox の CLI である <code>VBoxManage</code> の <code>controlvm</code> コマンドを使います。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VBoxManage controlvm &lt;VM_NAME&gt; natpf&lt;1-N&gt; <span class="string">"&lt;RULE_NAME&gt;,tcp,&lt;LOCAL_IP&gt;,&lt;LOCAL_PORT&gt;,&lt;VM_IP&gt;,&lt;VM_PORT&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;LOCAL_*&gt;</code> はローカルマシンのものを、 <code>&lt;VM_*&gt;</code> はホスト VM のものを表します。<br><code>&lt;RULE_NAME&gt;</code> はルール名で、わかりやすいように名付けるとよいです。 また <code>&lt;VM_IP&gt;</code> は省略可能です。</p><p>では実際に試してみましょう。たとえば、 PostgreSQL の Docker コンテナのポート 5432 をローカルの 5432 にポートフォワーディングしたい場合を考えます。以下のように、コンテナからホスト VM へはあらかじめポートフォワーディングされているものとします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -e POSTGRES_PASSWORD=password -d -p 5432:5432 postgres</span><br><span class="line">fd17b2e20ee3b09bbb446449f4182ad0aea24d2a4f4e8ba1a700c11af6671970</span><br><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED                  STATUS              PORTS                    NAMES</span><br><span class="line">fd17b2e20ee3        postgres            <span class="string">"/docker-entrypoint.s"</span>   Less than a second ago   Up 1 seconds        0.0.0.0:5432-&gt;5432/tcp   serene_varahamihira</span><br></pre></td></tr></table></figure><p>このとき、ホスト VM 名が <code>dev</code> であるとすると、ホスト VM の 5432 から ローカルの 5432 にポートフォワーディングするには、以下のコマンドを実行します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ VBoxManage controlvm dev natpf1 <span class="string">"psql_pf,tcp,127.0.0.1,5432,,5432"</span></span><br></pre></td></tr></table></figure><p>では確かめてみましょう (OS X の場合)。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ lsof -P -i -n | grep <span class="string">':5432 '</span></span><br><span class="line">VBoxHeadl 7103 skatsuta   21u  IPv4 0xd95e1bb443caee89      0t0  TCP 127.0.0.1:5432 (LISTEN)</span><br></pre></td></tr></table></figure><p>きちんと 5432 番で listen していますね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;VirtulaBox-の-VM-からローカルへのポートフォワーディング&quot;&gt;&lt;a href=&quot;#VirtulaBox-の-VM-からローカルへのポートフォワーディング&quot; class=&quot;headerlink&quot; title=&quot;VirtulaBox の VM からローカル
      
    
    </summary>
    
    
      <category term="VirtualBox" scheme="https://skatsuta.github.io/tags/VirtualBox/"/>
    
      <category term="Boot2Docker" scheme="https://skatsuta.github.io/tags/Boot2Docker/"/>
    
      <category term="Docker Machine" scheme="https://skatsuta.github.io/tags/Docker-Machine/"/>
    
      <category term="Docker" scheme="https://skatsuta.github.io/tags/Docker/"/>
    
      <category term="PostgreSQL" scheme="https://skatsuta.github.io/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Docker Machine の環境変数を rc ファイル内で自動で設定する</title>
    <link href="https://skatsuta.github.io/2015/07/29/docker-machine-rc/"/>
    <id>https://skatsuta.github.io/2015/07/29/docker-machine-rc/</id>
    <published>2015-07-29T03:50:05.000Z</published>
    <updated>2018-03-13T08:06:37.809Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 以外で Docker を使うには、Linux のホストマシンを VM で用意する必要があります。もっともメジャーなのは <a href="http://boot2docker.io" target="_blank" rel="noopener">Boot2Docker</a> でしょうが、個人的には <a href="https://docs.docker.com/machine/" target="_blank" rel="noopener">Docker Machine</a> を使うのがおすすめです。まだベータ版ですが、基本的な機能は特に問題なく使えています。</p><p>Docker Machine は複数のホスト VM を切り替えることができるのが1つの利点ですが、これにより逆に不便になってしまったことがあります。 Boot2Docker を使う場合、ホスト VM 起動後</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ boot2docker shellinit</span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=tcp://192.168.59.103:2376</span><br><span class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=/Users/skatsuta/.boot2docker/certs/boot2docker-vm</span><br><span class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=1</span><br></pre></td></tr></table></figure><p>により生成される環境変数を設定するために、 <code>.bashrc</code> や <code>.zshrc</code> などに</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(boot2docker shellinit)</span>"</span></span><br></pre></td></tr></table></figure><p>と書いておけばいいのですが、 Docker Machine の場合はホストを複数作れるために、上記のように一筋縄ではいきません。</p><p>Docker Machine で同じように環境変数を設定する場合、以下のようにホスト VM の名前の指定が必要です。たとえば <code>dev</code> というホスト VM を作った場合、</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine env dev</span><br><span class="line"><span class="built_in">export</span> DOCKER_TLS_VERIFY=<span class="string">"1"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_HOST=<span class="string">"tcp://192.168.99.101:2376"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_CERT_PATH=<span class="string">"/Users/skatsuta/.docker/machine/machines/dev"</span></span><br><span class="line"><span class="built_in">export</span> DOCKER_MACHINE_NAME=<span class="string">"dev"</span></span><br><span class="line"><span class="comment"># Run this command to configure your shell:</span></span><br><span class="line"><span class="comment"># eval "$(docker-machine env dev)"</span></span><br></pre></td></tr></table></figure><p>で環境変数が取得できます。このホスト VM 名は存在し、かつ動いているものでなければなりません。</p><p>いろいろ模索と妥協をした結果、 <code>docker-machine ls</code> コマンドと組み合わせることにより、現状動いているホスト VM を1つ取り出して、その環境変数を設定するシェルスクリプトを <code>.zshrc</code> に書くことにしました。</p><h5 id="zshrc"><a href="#zshrc" class="headerlink" title=".zshrc"></a>.zshrc</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check if `docker-machine` command exists</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">command</span> -v docker-machine &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># fetch the first running machine name</span></span><br><span class="line">  <span class="built_in">local</span> machine=$(docker-machine ls | grep Running | head -n 1 | awk <span class="string">'&#123; print $1 &#125;'</span>)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">"<span class="variable">$machine</span>"</span> != <span class="string">""</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(docker-machine env $machine)</span>"</span></span><br><span class="line">    <span class="built_in">export</span> DOCKER_IP=$(docker-machine ip <span class="variable">$machine</span>)</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>IP アドレスだけを使いたいときもあるので、同時に <code>DOCKER_IP</code> という変数も設定しています。</p><p>これでちょっとだけ手間が省けます。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 以外で Docker を使うには、Linux のホストマシンを VM で用意する必要があります。もっともメジャーなのは &lt;a href=&quot;http://boot2docker.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Boot2Doc
      
    
    </summary>
    
    
      <category term="Docker Machine" scheme="https://skatsuta.github.io/tags/Docker-Machine/"/>
    
      <category term="Docker" scheme="https://skatsuta.github.io/tags/Docker/"/>
    
      <category term="bashrc" scheme="https://skatsuta.github.io/tags/bashrc/"/>
    
      <category term="zshrc" scheme="https://skatsuta.github.io/tags/zshrc/"/>
    
  </entry>
  
  <entry>
    <title>Go 1.5 の変更点</title>
    <link href="https://skatsuta.github.io/2015/07/28/go-1-5/"/>
    <id>https://skatsuta.github.io/2015/07/28/go-1-5/</id>
    <published>2015-07-28T01:45:13.000Z</published>
    <updated>2018-03-13T08:06:37.809Z</updated>
    
    <content type="html"><![CDATA[<p>間もなく Go 1.5 がリリースされるようなので、 release notes の原稿から気になる変更点をピックアップしてみました。</p><h2 id="言語仕様"><a href="#言語仕様" class="headerlink" title="言語仕様"></a>言語仕様</h2><h3 id="構造体をキーとした-map-リテラルの簡略化"><a href="#構造体をキーとした-map-リテラルの簡略化" class="headerlink" title="構造体をキーとした map リテラルの簡略化"></a>構造体をキーとした map リテラルの簡略化</h3><p>構造体をキーとした map のリテラルを少し簡単に書けるようになります。たとえば、これまでは</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[Point]<span class="keyword">string</span>&#123;</span><br><span class="line">    Point&#123;<span class="number">29.935523</span>, <span class="number">52.891566</span>&#125;:   <span class="string">"Persepolis"</span>,</span><br><span class="line">    Point&#123;<span class="number">-25.352594</span>, <span class="number">131.034361</span>&#125;: <span class="string">"Uluru"</span>,</span><br><span class="line">    Point&#123;<span class="number">37.422455</span>, <span class="number">-122.084306</span>&#125;: <span class="string">"Googleplex"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>と書いていたものが、</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[Point]<span class="keyword">string</span>&#123;</span><br><span class="line">    &#123;<span class="number">29.935523</span>, <span class="number">52.891566</span>&#125;:   <span class="string">"Persepolis"</span>,</span><br><span class="line">    &#123;<span class="number">-25.352594</span>, <span class="number">131.034361</span>&#125;: <span class="string">"Uluru"</span>,</span><br><span class="line">    &#123;<span class="number">37.422455</span>, <span class="number">-122.084306</span>&#125;: <span class="string">"Googleplex"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>と書けるようになります。</p><h2 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h2><h3 id="C-のソースコードの削除"><a href="#C-のソースコードの削除" class="headerlink" title="C のソースコードの削除"></a>C のソースコードの削除</h3><p>コンパイラとランタイムがすべて Go で書き換えられ、C のコードは排除されました。</p><h3 id="ガベージコレクタ"><a href="#ガベージコレクタ" class="headerlink" title="ガベージコレクタ"></a>ガベージコレクタ</h3><p>GC 処理のアルゴリズム改善・スケジューリング改善・並列化により、レイテンシが劇的に小さくなります。アプリケーションの動きが完全に停止する “stop the world” の時間はほとんどの場合 10 ミリ秒以下に抑えられるようです。</p><h3 id="ランタイム"><a href="#ランタイム" class="headerlink" title="ランタイム"></a>ランタイム</h3><p><code>GOMAXPROCS</code> のデフォルト値が 1 からコア数になります。シングルスレッド前提で書かれているプログラムにはもしかすると影響が出るかもしれません。</p><h2 id="ポート"><a href="#ポート" class="headerlink" title="ポート"></a>ポート</h2><p><code>darwin/arm</code>, <code>darwin/arm64</code> (iOS) と <code>linux/arm64</code> がサポートされました。</p><h2 id="ツール"><a href="#ツール" class="headerlink" title="ツール"></a>ツール</h2><h3 id="コンパイラ・リンカ"><a href="#コンパイラ・リンカ" class="headerlink" title="コンパイラ・リンカ"></a>コンパイラ・リンカ</h3><p><code>6g</code>, <code>8g</code> などのコンパイラ・リンカはなくなり、<code>go tool compile</code>, <code>go tool link</code> などに置き換えられました。</p><h3 id="新たなデフォルトコマンドの追加"><a href="#新たなデフォルトコマンドの追加" class="headerlink" title="新たなデフォルトコマンドの追加"></a>新たなデフォルトコマンドの追加</h3><p><code>go vet</code>, <code>go cover</code>, <code>go doc</code> コマンドが標準で使えるようになりました。</p><ul><li><code>vet</code> はソースコードのバリデーションや静的解析をおこなうツールです。</li><li><code>cover</code> はカバレッジを計算してくれるツールです。</li></ul><p><code>vet</code> や <code>cover</code> はよく使っているので、標準で同梱されるようになると嬉しいですね。</p><h3 id="Go-コマンド"><a href="#Go-コマンド" class="headerlink" title="Go コマンド"></a>Go コマンド</h3><h4 id="Internal-package"><a href="#Internal-package" class="headerlink" title="Internal package"></a>Internal package</h4><p>Go でのアクセス制御はこれまで public か private しか指定できませんでした。 Go 1.4 で <strong>internal package</strong> という、パッケージプライベートを実現する機能が試験的に導入されましたが、この段階ではまだコアライブラリでしか利用できるようになっていませんでした。 Go 1.5 でこの機能がユーザライブラリにも開放されます。</p><p>具体的には、パッケージ名に <code>internal</code> が含まれている場合、同一のルートパッケージからのみ import できます。たとえば、 <code>$GOPATH/src/mypkg/internal/foo</code> というパッケージは、 <code>$GOPATH/src/mypkg</code> からのみ import できます。</p><p>細かい仕様は<a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit" target="_blank" rel="noopener">デザインドキュメント</a>に記載されています。<a href="http://qiita.com/taka011239@github/items/5735a1ec78bad06f5485" target="_blank" rel="noopener">go1.4で追加されたinternal packageについて - Qiita</a> の記事なども参考になります。</p><h4 id="Verdoring"><a href="#Verdoring" class="headerlink" title="Verdoring"></a>Verdoring</h4><p>Verdoring 機能が実験的にサポートされました。これはどういうものかというと、たとえば</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$GOPATH</span><br><span class="line">|    src/</span><br><span class="line">|    |    github.com/constabulary/example-gsftp/</span><br><span class="line">|    |    |    cmd/</span><br><span class="line">|    |    |    |    gsftp/</span><br><span class="line">|    |    |    |    |    main.go</span><br><span class="line">|    |    |    vendor/</span><br><span class="line">|    |    |    |    github.com/pkg/sftp/</span><br><span class="line">|    |    |    |    golang.org/x/crypto/ssh/</span><br><span class="line">|    |    |    |    |    agent/</span><br></pre></td></tr></table></figure><p>というリポジトリ構成にしておくと、 <code>github.com/constabulary/example-gsftp/cmd/gsftp/main.go</code> において</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"golang.org/x/crypto/ssh"</span></span><br><span class="line">    <span class="string">"golang.org/x/crypto/ssh/agent"</span></span><br><span class="line">    <span class="string">"github.com/pkg/sftp"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>と書けば <code>verdor</code> 以下の依存ライブラリを import できるようになります。 これまでは</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">"github.com/constabulary/example-gsftp/vendor/golang.org/x/crypto/ssh"</span></span><br><span class="line">    <span class="string">"github.com/constabulary/example-gsftp/vendor/golang.org/x/crypto/ssh/agent"</span></span><br><span class="line">    <span class="string">"github.com/constabulary/example-gsftp/vendor/github.com/pkg/sftp"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>というふうにフルパスを書かなければならなかったので、だいぶ楽になります。</p><p>ただしこの機能を有効にするには環境変数で <code>GO15VENDOREXPERIMENT=1</code> と設定する必要があります。</p><p>これまで Go にはライブラリのバージョン指定機能がなかったため、たとえば依存関係解決ツールである <a href="https://github.com/tools/godep" target="_blank" rel="noopener">Godep</a> では <code>Godep/_workspace/</code> で同じような機構を実現していました。 Go 1.5 からはこの標準機能を使っていくことになるでしょう。</p><h2 id="標準ライブラリ"><a href="#標準ライブラリ" class="headerlink" title="標準ライブラリ"></a>標準ライブラリ</h2><h3 id="flag-パッケージ"><a href="#flag-パッケージ" class="headerlink" title="flag パッケージ"></a><code>flag</code> パッケージ</h3><p><code>flag</code> パッケージの help の表示が見やすくなりました。たとえば</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpuFlag = flag.Int(<span class="string">"cpu"</span>, <span class="number">1</span>, <span class="string">"run `N` processes in parallel"</span>)</span><br></pre></td></tr></table></figure><p>というフラグを定義すると、 <code>help</code> メッセージは</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-cpu N</span><br><span class="line">        run N processes in parallel (default 1)</span><br></pre></td></tr></table></figure><p>と表示されるようになります。 Go 1.4 までは</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-cpu=1  run N processes in parallel</span><br></pre></td></tr></table></figure><p>という表示だったので、少し見やすくなります。</p><h3 id="math-big-パッケージ"><a href="#math-big-パッケージ" class="headerlink" title="math/big パッケージ"></a><code>math/big</code> パッケージ</h3><p><code>math/big</code> パッケージに、任意精度の浮動小数点型である <code>Float</code> が追加されます。</p><h3 id="reflect-パッケージ"><a href="#reflect-パッケージ" class="headerlink" title="reflect パッケージ"></a><code>reflect</code> パッケージ</h3><p><code>reflect</code> パッケージに <code>ArrayOf</code> と <code>FuncOf</code> 関数が追加されます。 <code>SliceOf</code> と同様に、実行時に配列や関数を表す型をつくることができるようになります。</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>個人的な見どころはやはり GC の改善と internal package ですね。正式リリースが待ち遠しいです。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;間もなく Go 1.5 がリリースされるようなので、 release notes の原稿から気になる変更点をピックアップしてみました。&lt;/p&gt;
&lt;h2 id=&quot;言語仕様&quot;&gt;&lt;a href=&quot;#言語仕様&quot; class=&quot;headerlink&quot; title=&quot;言語仕様&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Go" scheme="https://skatsuta.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>wercker 上で Aerospike を使ったテストをする</title>
    <link href="https://skatsuta.github.io/2015/07/22/wercker-aerospike/"/>
    <id>https://skatsuta.github.io/2015/07/22/wercker-aerospike/</id>
    <published>2015-07-22T05:35:57.000Z</published>
    <updated>2018-03-13T08:06:37.812Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://blog.wercker.com/2015/04/02/Introducing-our-docker-stack.html" target="_blank" rel="noopener">wercker が最近 Docker に対応しました。</a> これにより、 Docker を利用している場合にはテストからデプロイまでを共通したコンテナでおこなえるほか、既存のコンテナを再利用し、柔軟に組み合わせて利用できるようになりました。</p><p>最近 <a href="http://www.aerospike.com" target="_blank" rel="noopener">Aerospike</a> という超優秀な KVS を利用しているのですが、 Docker ベースになった werkcer 上でこのクライアントライブラリのユニットテストを実行したいと思ったので試してみました。</p><p>werker には <a href="http://devcenter.wercker.com/docs/services/index.html" target="_blank" rel="noopener">services</a> という、 複数のコンテナを外部サービスとして利用する仕組みがあります。この機構により、使用するミドルウェアのコンテナイメージを用意すれば、 CI 時にそれを利用したテストを走らせることができます。素晴らしい仕組みです。たとえば、 Redis を使用したければ、<code>wercker.yml</code> の <code>services</code> セクションに以下のように <code>redis</code> を追記します。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">redis</span></span><br></pre></td></tr></table></figure><p>これにより、 CI 時に Docker Hub の Redis イメージが pull されてきて、 アプリケーションから利用できるようになります。 Aerospike を使う場合も同様で、 <code>wercker.yml</code> に以下のように書きます。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">aerospike</span></span><br></pre></td></tr></table></figure><p>こうすると、ビルド時に Docker Hub の <a href="https://registry.hub.docker.com/_/aerospike/" target="_blank" rel="noopener">aerospike</a> リポジトリからイメージを取得して、利用できるようにしてくれます。</p><p>では、アプリケーション側からこれらのサービスにアクセスするにはどうすればよいのでしょうか？<br>wercker では <a href="https://docs.docker.com/userguide/dockerlinks/#environment-variables" target="_blank" rel="noopener">Docker のコンテナ間リンク機構</a> を利用して、 <a href="http://devcenter.wercker.com/docs/services/available-env-vars.html" target="_blank" rel="noopener">環境変数が自動で準備されるようになってます</a>。 Aerospike を使用した場合には、以下のような環境変数が用意されることになります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">AEROSPIKE_ENV_AEROSPIKE_SHA256=df810e67d363291f6f40c046564bbc7ab775fcdb45ebfb878368361705063015</span><br><span class="line">AEROSPIKE_ENV_AEROSPIKE_VERSION=3.5.14</span><br><span class="line">AEROSPIKE_NAME=/wercker-pipeline-55ae303ff32b86a92907041f/aerospike</span><br><span class="line">AEROSPIKE_PORT=tcp://172.17.6.203:3000</span><br><span class="line">AEROSPIKE_PORT_3000_TCP=tcp://172.17.6.203:3000</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_ADDR=172.17.6.203</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_END=tcp://172.17.6.203:3003</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_PORT=3000</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_PORT_END=3003</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_PORT_START=3000</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_PROTO=tcp</span><br><span class="line">AEROSPIKE_PORT_3000_TCP_START=tcp://172.17.6.203:3000</span><br><span class="line">AEROSPIKE_PORT_3001_TCP=tcp://172.17.6.203:3001</span><br><span class="line">AEROSPIKE_PORT_3001_TCP_ADDR=172.17.6.203</span><br><span class="line">AEROSPIKE_PORT_3001_TCP_PORT=3001</span><br><span class="line">AEROSPIKE_PORT_3001_TCP_PROTO=tcp</span><br><span class="line">AEROSPIKE_PORT_3002_TCP=tcp://172.17.6.203:3002</span><br><span class="line">AEROSPIKE_PORT_3002_TCP_ADDR=172.17.6.203</span><br><span class="line">AEROSPIKE_PORT_3002_TCP_PORT=3002</span><br><span class="line">AEROSPIKE_PORT_3002_TCP_PROTO=tcp</span><br><span class="line">AEROSPIKE_PORT_3003_TCP=tcp://172.17.6.203:3003</span><br><span class="line">AEROSPIKE_PORT_3003_TCP_ADDR=172.17.6.203</span><br><span class="line">AEROSPIKE_PORT_3003_TCP_PORT=3003</span><br><span class="line">AEROSPIKE_PORT_3003_TCP_PROTO=tcp</span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/userguide/dockerlinks/" target="_blank" rel="noopener">ドキュメント</a> にある通り、環境変数の命名規則は</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;_PORT_&lt;port&gt;_&lt;protocol&gt;</span><br></pre></td></tr></table></figure><p>をプレフィックスとして、 <code>prefix_ADDR</code> なら IP アドレス、 <code>prefix_PORT</code> ならポート番号、 <code>prefix_PROTO</code> ならプロトコル名になっています。なおかつ、<a href="https://registry.hub.docker.com/u/aerospike/aerospike-server/dockerfile/" target="_blank" rel="noopener">Aerospike の Dockerfile</a> が実行されるので、 3000 ~ 3003 番のポートに対応する環境変数がそれぞれ用意されていますね。</p><p>したがって、あとはアプリケーション側が環境変数から必要な値を取得するような実装になっていればよいことになります。たとえば Go 言語であれば、 以下のように <code>os.Getenv()</code> を使えばよいでしょう。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr := os.Getenv(<span class="string">"AEROSPIKE_PORT_3000_TCP_ADDR"</span>)</span><br></pre></td></tr></table></figure><p>これで、 DB などの外部サービスに依存したテストも wercker 上で実行できるようになりました！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://blog.wercker.com/2015/04/02/Introducing-our-docker-stack.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wercker が最近 Docker に対応しました。
      
    
    </summary>
    
    
      <category term="Aerospike" scheme="https://skatsuta.github.io/tags/Aerospike/"/>
    
      <category term="wercker" scheme="https://skatsuta.github.io/tags/wercker/"/>
    
  </entry>
  
  <entry>
    <title>GitHub アカウントを使っている場合に wercker CLI で認証を通す方法</title>
    <link href="https://skatsuta.github.io/2015/07/21/wercker-github-login/"/>
    <id>https://skatsuta.github.io/2015/07/21/wercker-github-login/</id>
    <published>2015-07-21T07:29:35.000Z</published>
    <updated>2018-03-13T08:06:37.812Z</updated>
    
    <content type="html"><![CDATA[<p>先進的な CI サービスである <a href="http://wercker.com" target="_blank" rel="noopener">wercker</a> では、 <a href="http://wercker.com/downloads" target="_blank" rel="noopener">CLI が提供されています</a>。これを使うと、 wercker でのビルドプロセスをローカルで再現できたり、 ビルド済みのコンテナを pull してきて、中の状態を確認できたりします。 OS X 用と Linux 用が提供されており、 OS X の場合には、以下のコマンドで一発です。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -L https://s3.amazonaws.com/downloads.wercker.com/cli/stable/darwin_amd64/wercker -o /usr/<span class="built_in">local</span>/bin/wercker</span><br></pre></td></tr></table></figure><p>この <code>wercker</code> コマンドを使ってコンテナイメージを pull してくるには、あらかじめ <code>wercker login</code> で wercker のアカウントでログインしておく必要があります。そうでないと、以下のようなメッセージが表示されてしまいます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ wercker pull skatsuta/aerospike-sample --branch master --load</span><br><span class="line">Fetching build information <span class="keyword">for</span> application skatsuta/aerospike-sample</span><br><span class="line">ERROR wercker-api: You are not authorized to access the resource (status code: 401)</span><br></pre></td></tr></table></figure><p>ところが僕は GitHub のアカウントを使っており、このログイン情報では次のように認証が通りません。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ wercker login</span><br><span class="line"><span class="comment">########### Logging into wercker! #############</span></span><br><span class="line">Username: skatsuta</span><br><span class="line">Password:</span><br><span class="line">ERROR Unable to <span class="built_in">log</span> into wercker Error=Invalid credentials</span><br><span class="line">ERROR Invalid credentials</span><br></pre></td></tr></table></figure><p>どうなってるのかと思い <a href="https://github.com/wercker/wercker-cli" target="_blank" rel="noopener">wercker/wercker-cli</a> リポジトリの issues を見てみると、以下のような issue が挙げられていました。</p><ul><li><a href="httpsc//github.com/wercker/wercker-cli/issues/15">Issue #15: wercker login ends with “A valid token is required!”</a></li><li><a href="https://github.com/wercker/wercker-cli/issues/16" target="_blank" rel="noopener">Issue #16: Login with Github account?</a></li></ul><p>案の定 GitHub アカウントでのログインには未対応のようです。しかしながら、 <a href="httpsc//github.com/wercker/wercker-cli/issues/15">Issue #15</a> の <a href="https://github.com/captn3m0" target="_blank" rel="noopener">@captn3m0</a> のコメントに興味深いことが書かれていました。</p><blockquote><p>Alternatively, you can add instructions to directly generate a token and putting it in the ~/.werkcer/token file</p></blockquote><p>なんと、トークンファイルを置いておけばいけると!?<br>ということで、早速試してみました。</p><p>wercker のアカウントページの右上のアイコンから Settings &gt; Personal tokens をたどり、 <code>wercker-cli</code> という名前でトークンを生成し、コピーします。そしてそれを <code>~/.wercker/token</code> ファイルに貼り付けて保存します。</p><p>さて、もう一度 pull してみましょう。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ wercker pull skatsuta/aerospike-sample --branch master --load</span><br><span class="line">Fetching build information <span class="keyword">for</span> application skatsuta/aerospike-sample</span><br><span class="line">Downloading Docker repository <span class="keyword">for</span> build 55a3aaad50dc24ba7b102720</span><br><span class="line">Downloading: 100%</span><br><span class="line">Download complete</span><br><span class="line">Importing into Docker</span><br><span class="line">Finished importing into Docker</span><br></pre></td></tr></table></figure><p>本当に成功しました！ これで wercker CLI を活用できますね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先進的な CI サービスである &lt;a href=&quot;http://wercker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wercker&lt;/a&gt; では、 &lt;a href=&quot;http://wercker.com/downloads&quot; target
      
    
    </summary>
    
    
      <category term="wercker" scheme="https://skatsuta.github.io/tags/wercker/"/>
    
      <category term="GitHub" scheme="https://skatsuta.github.io/tags/GitHub/"/>
    
      <category term="CLI" scheme="https://skatsuta.github.io/tags/CLI/"/>
    
  </entry>
  
  <entry>
    <title>wercker 上で Java / Scala プロジェクトの依存ライブラリをキャッシュする</title>
    <link href="https://skatsuta.github.io/2015/06/07/java-werkcer/"/>
    <id>https://skatsuta.github.io/2015/06/07/java-werkcer/</id>
    <published>2015-06-07T08:52:34.000Z</published>
    <updated>2018-03-13T08:06:37.811Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://wercker.com" target="_blank" rel="noopener">wercker</a> は今ある CI サービスの中ではもっともイケてるものだと思います。 box と step という仕組みにより、ビルドをおこなう環境とビルド処理を分離し、再利用性を高めています。<a href="http://blog.wercker.com/2015/04/02/Introducing-our-docker-stack.html" target="_blank" rel="noopener">最近 Docker にも対応したようです</a>。まだ Beta 期間中のため、プライベートリポジトリも無料で利用できます。</p><p>最近、 <a href="https://www.playframework.com/" target="_blank" rel="noopener">Play Framework</a> を使ったプロジェクトの開発でこの wercker を使用してみたのですが、試しにビルドしてみたら何と<strong>2回め以降のビルドでも毎回依存ライブラリをすべてダウンロードしているではないですか!!!</strong></p><p>これは困った…どうにかならないもんか…と思ってやってみたのがこの記事です。</p><p>僕が今回取り組んだのが <a href="https://www.playframework.com/" target="_blank" rel="noopener">Play Framework</a> を使ったプロジェクトだったため、それを題材に書きますが、本質的には Ant だろうと Maven だろうと Gradle だろうと sbt だろうと、もっと言えば Java / Scala に限らずどの言語のプロジェクトでも同じようにできるはずです。ぶっちゃけた話、単に rsync を使って自力でキャッシュを保存/復元しているだけですので。</p><h2 id="キャッシュのためのディレクティブがない-wercker"><a href="#キャッシュのためのディレクティブがない-wercker" class="headerlink" title="キャッシュのためのディレクティブがない wercker"></a>キャッシュのためのディレクティブがない wercker</h2><p>メジャーな CI サービスにはキャッシュを制御するディレクティブが用意されているものもあります。<br>たとえば <a href="https://travis-ci.org/" target="_blank" rel="noopener">Travis CI</a> では</p><h5 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a>.travis.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">vendor/bundle</span></span><br></pre></td></tr></table></figure><p>と書いておけば <code>vendor/bundle</code> がキャッシュされます。<br><a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a> は至れり尽くせりで、 Java / Scala のプロジェクトの場合には</p><ul><li><code>~/.m2</code></li><li><code>~/.ivy2</code></li><li><code>~/.gradle</code></li><li><code>~/.play</code></li></ul><p>を自動で（暗黙的に）キャッシュしてくれますし、明示的にキャッシュしたいものは</p><h5 id="circle-yml"><a href="#circle-yml" class="headerlink" title="circle.yml"></a>circle.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line"><span class="attr">  cache_directories:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">~/.sbt</span></span><br></pre></td></tr></table></figure><p>のように書いておけば <code>~/.sbt</code> がキャッシュされます。</p><p>一方 wercker はまだ若いサービスのためか、上記のようなキャッシュ機構がきちんと整っておらず、今のところ用意されているのは環境変数 <strong><code>$WERCKER_CACHE_DIR</code></strong> のみのようです (少なくとも僕が探した限りは見つかりませんでした)。</p><p>ビルドのたびに依存ライブラリを1からダウンロードされてはたまったもんじゃないので、何とかキャッシュの仕組みを作れないかとやってみました。</p><h2 id="参考サイト"><a href="#参考サイト" class="headerlink" title="参考サイト"></a>参考サイト</h2><p>以下の wercker の公式ブログの記事を参考にさせていただきました。</p><ul><li><a href="http://blog.wercker.com/2013/07/25/improving-Go-build-time-with-wercker-cache.html" target="_blank" rel="noopener">Improving golang build times with the wercker cache</a></li></ul><p>上記記事では Go のプロジェクトにおいて、 <code>go get</code> してきた依存ライブラリを rsync を使って <code>$WERCKER_CACHE_DIR</code> に保存したりそこから復元したりして、 ビルド時間を短縮しています。<br>Java や Scala のプロジェクトでも考え方は同じなので、上記記事を参考にして自分なりのやり方を組み立てました。</p><h2 id="要は何をすればよいか"><a href="#要は何をすればよいか" class="headerlink" title="要は何をすればよいか"></a>要は何をすればよいか</h2><ol><li>ビルドステップの最初に <code>$WERCKER_CACHE_DIR</code> からキャッシュを復元する</li><li>ビルドステップの最後に <code>$WERCKER_CACHE_DIR</code> にキャッシュを保存する</li></ol><p>要はこれだけなのですが、</p><ul><li>キャッシュの保存に rsync を使うために、 rsync をインストールした box を作った</li><li>キャッシュの保存/復元作業をまとめたシェルスクリプトを書いた</li></ul><p>ということをしたので、ちょっと手間暇をかけました。</p><h2 id="rsync-をインストールした-box-をつくる"><a href="#rsync-をインストールした-box-をつくる" class="headerlink" title="rsync をインストールした box をつくる"></a>rsync をインストールした box をつくる</h2><p>キャッシュの保存/復元は <code>cp</code> コマンドとかでもいいのでしょうが、<a href="http://blog.wercker.com/2013/07/25/improving-Go-build-time-with-wercker-cache.html" target="_blank" rel="noopener">先の記事</a>でも rsync を使っていましたし、確かに効率を考えると rsync がよさそうです。しかしビルドのたびに rsync をインストールするのも無駄です。そこで、 wercker にはせっかく box という素晴らしい仕組みがあるので、あらかじめ rsync をインストールした box をつくり、それを利用することにしました。</p><p>ありがたいことに、 Java 8 と <a href="http://www.typesafe.com/get-started" target="_blank" rel="noopener">Typesafe Activator</a> をインストールした <a href="https://github.com/mitsuse/wercker-box-activator" target="_blank" rel="noopener">mitsuse/wercker-box-activator</a> という box がすでにありましたので、 fork させていただき、 rsync をインストールする処理を追記しました。</p><ul><li>GitHub repository: <a href="https://github.com/skatsuta/wercker-box-activator" target="_blank" rel="noopener">skatsuta/wercker-box-activator</a></li><li>wercker registory: <a href="https://app.wercker.com/#applications/5561de99be632a8c75080ae9/tab/details" target="_blank" rel="noopener">skatsuta/wercker-box-activator</a></li></ul><h2 id="キャッシュ処理用のシェルスクリプトを書く"><a href="#キャッシュ処理用のシェルスクリプトを書く" class="headerlink" title="キャッシュ処理用のシェルスクリプトを書く"></a>キャッシュ処理用のシェルスクリプトを書く</h2><p>簡単な処理であれば wercker.yml に直接書いてしまえばよいのですが、キャッシュ処理が長くなりそうだったので、シェルスクリプトにまとめることにしました。<br>以下は Play Framework の例です。 Play Framework ではキャッシュディレクトリは <code>~/.ivy2</code> と <code>~/.sbt</code> なので、その2つを指定しています。</p><h5 id="wercker-cache-sh"><a href="#wercker-cache-sh" class="headerlink" title="wercker_cache.sh"></a>wercker_cache.sh</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#=========================================</span></span><br><span class="line"><span class="comment"># Script for storing and restoring cache</span></span><br><span class="line"><span class="comment">#   in Java / Scala project on werkcer</span></span><br><span class="line"><span class="comment">#=========================================</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># cache directories</span></span><br><span class="line">CACHES=( <span class="string">"ivy2"</span> <span class="string">"sbt"</span> )</span><br><span class="line">CMD=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># check if rsync exists</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">type</span> rsync &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"[ERROR] rsync needs to be installed."</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># set source and destination directories</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$CMD</span> <span class="keyword">in</span></span><br><span class="line">    <span class="string">"store"</span>)</span><br><span class="line">        SRC=<span class="variable">$HOME</span></span><br><span class="line">        DST=<span class="variable">$WERCKER_CACHE_DIR</span></span><br><span class="line">        ;;</span><br><span class="line">    <span class="string">"restore"</span>)</span><br><span class="line">        SRC=<span class="variable">$WERCKER_CACHE_DIR</span></span><br><span class="line">        DST=<span class="variable">$HOME</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># run rsync</span></span><br><span class="line"><span class="keyword">for</span> cache <span class="keyword">in</span> <span class="string">"<span class="variable">$&#123;CACHES[@]&#125;</span>"</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> -d <span class="variable">$SRC</span>/.<span class="variable">$cache</span>; <span class="keyword">then</span></span><br><span class="line">        rsync -avz <span class="variable">$SRC</span>/.<span class="variable">$cache</span> <span class="variable">$DST</span>/</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>Gist を貼り付けるとレイアウトが崩れてしまうので、 <a href="https://gist.github.com/skatsuta/8f63194dfd65712da640" target="_blank" rel="noopener">Gist 版はこちら</a></p><p>単に rsync で <code>$WERCKER_CACHE_DIR</code> へ保存したり、そこから復元したりしているだけです。<br>このシェルスクリプトをプロジェクトのリポジトリに入れておきます (たとえば <code>sh/wercker_cache.sh</code> など)。</p><h2 id="wercker-yml-にキャッシュの保存-復元処理を書く"><a href="#wercker-yml-にキャッシュの保存-復元処理を書く" class="headerlink" title="wercker.yml にキャッシュの保存/復元処理を書く"></a>wercker.yml にキャッシュの保存/復元処理を書く</h2><p>最後に、 <code>wercker.yml</code> にキャッシュの保存/復元処理を書きます。<br>以下はサンプルで、 <code>sh/wercker_cache.sh</code> に先のスクリプトが入っているとします。</p><h5 id="wercker-yml"><a href="#wercker-yml" class="headerlink" title="wercker.yml"></a>wercker.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">box:</span> <span class="string">skatsuta/activator@0.0.3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  steps:</span></span><br><span class="line"><span class="attr">    - script:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">restore</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">        code:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sh/wercker_cache.sh restore</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">    - script:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">run</span> <span class="string">activator</span> <span class="string">test</span></span><br><span class="line"><span class="attr">        code:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          activator test</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span><span class="attr">    - script:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">store</span> <span class="string">cache</span></span><br><span class="line"><span class="attr">        code:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sh/wercker_cache.sh store</span></span><br></pre></td></tr></table></figure><p>これで wercker 上でビルドしてみると、2回目以降は <strong>restore cache</strong> というステップで各キャッシュがホームディレクトリに復元され、 <strong>store cache</strong> というステップで前回のキャッシュディレクトリとの差分が保存されていることが確認できると思います。</p><h2 id="ビルド時間の短縮に成功！"><a href="#ビルド時間の短縮に成功！" class="headerlink" title="ビルド時間の短縮に成功！"></a>ビルド時間の短縮に成功！</h2><p>僕のプロジェクトではこのおかげで wercker 上でのビルド時間を<strong>2分弱</strong>短縮することができました。めでたしめでたし。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://wercker.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wercker&lt;/a&gt; は今ある CI サービスの中ではもっともイケてるものだと思います。 box と step という仕組みにより、ビルドをおこなう環境
      
    
    </summary>
    
    
      <category term="wercker" scheme="https://skatsuta.github.io/tags/wercker/"/>
    
      <category term="Java" scheme="https://skatsuta.github.io/tags/Java/"/>
    
      <category term="Scala" scheme="https://skatsuta.github.io/tags/Scala/"/>
    
      <category term="Play Framework" scheme="https://skatsuta.github.io/tags/Play-Framework/"/>
    
      <category term="Ant" scheme="https://skatsuta.github.io/tags/Ant/"/>
    
      <category term="Maven" scheme="https://skatsuta.github.io/tags/Maven/"/>
    
      <category term="Gradle" scheme="https://skatsuta.github.io/tags/Gradle/"/>
    
      <category term="sbt" scheme="https://skatsuta.github.io/tags/sbt/"/>
    
  </entry>
  
  <entry>
    <title>AngularJS のフィルタを日本語表記に合わせる</title>
    <link href="https://skatsuta.github.io/2015/05/01/angularjs-filter-japanese/"/>
    <id>https://skatsuta.github.io/2015/05/01/angularjs-filter-japanese/</id>
    <published>2015-05-01T14:08:04.000Z</published>
    <updated>2018-03-13T08:06:37.808Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AngularJS-で-currency-フィルタや-date-フィルタを日本語の表記に合わせるには？"><a href="#AngularJS-で-currency-フィルタや-date-フィルタを日本語の表記に合わせるには？" class="headerlink" title="AngularJS で currency フィルタや date フィルタを日本語の表記に合わせるには？"></a>AngularJS で <code>currency</code> フィルタや <code>date</code> フィルタを日本語の表記に合わせるには？</h2><p>AngularJS のフィルタは便利な機能です。その中で <code>currency</code> フィルタや <code>date</code> フィルタといった、フォーマットを整えてくれるフィルタがありますが、デフォルトでは US 表記になっています。これを日本語の表記に合わせるには、angular-i18n モジュールを利用します。</p><p>以下の方法は <a href="http://qiita.com/katahirado/items/ca4a9a202374b5f8d9f9" target="_blank" rel="noopener">grunt-wiredep使用の環境でangular-i18nをbowerでインストールしたら注入できないとメッセージ - Qiita</a> を参考にさせていただきました。</p><h2 id="angular-i18n-モジュールをインストールする"><a href="#angular-i18n-モジュールをインストールする" class="headerlink" title="angular-i18n モジュールをインストールする"></a>angular-i18n モジュールをインストールする</h2><p>Bower を利用してインストールします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bower install angular-i18n --save</span><br><span class="line">bower not-cached    git://github.com/angular/bower-angular-i18n.git<span class="comment">#*</span></span><br><span class="line">bower resolve       git://github.com/angular/bower-angular-i18n.git<span class="comment">#*</span></span><br><span class="line">bower download      https://github.com/angular/bower-angular-i18n/archive/v1.2.24.tar.gz</span><br><span class="line">bower extract       angular-i18n<span class="comment">#* archive.tar.gz</span></span><br><span class="line">bower invalid-meta  angular-i18n is missing <span class="string">"main"</span> entry <span class="keyword">in</span> bower.json</span><br><span class="line">bower resolved      git://github.com/angular/bower-angular-i18n.git<span class="comment">#1.2.24</span></span><br><span class="line">bower install       angular-i18n<span class="comment">#1.2.24</span></span><br></pre></td></tr></table></figure><p>ん？ <code>bower invalid-meta  angular-i18n is missing &quot;main&quot; entry in bower.json</code> という警告が出ていますね。<br>同時に <code>gulp serve</code> などを走らせていた場合、以下のような警告が出てしまいます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">angular-i18n was not injected <span class="keyword">in</span> your file.</span><br><span class="line">Please go take a look <span class="keyword">in</span> <span class="string">"app/bower_components/angular-i18n"</span> <span class="keyword">for</span> the file you need, the manually include it <span class="keyword">in</span> your file.</span><br></pre></td></tr></table></figure><p>Bower が angular-i18n モジュールのうち、どのファイルをインクルードしていいのかわからないようです。</p><h2 id="angular-i18n-の-main-を指定する"><a href="#angular-i18n-の-main-を指定する" class="headerlink" title="angular-i18n の main を指定する"></a>angular-i18n の main を指定する</h2><p>bower.json で明示的に使用するロケールファイルを指定してあげましょう。</p><h5 id="bower-json"><a href="#bower-json" class="headerlink" title="bower.json"></a>bower.json</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"myApp"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  ... 省略 ....</span><br><span class="line">  <span class="string">"resolutions"</span>: &#123;</span><br><span class="line">    <span class="string">"angular"</span>: <span class="string">"1.3.x"</span>,</span><br><span class="line">    <span class="string">"jquery"</span>: <span class="string">"2.x.x"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//=== ここから追記 ===</span></span><br><span class="line">  <span class="string">"overrides"</span>: &#123;</span><br><span class="line">    <span class="string">"angular-i18n"</span>: &#123;</span><br><span class="line">      <span class="string">"main"</span>: <span class="string">"angular-locale_ja-jp.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//=== ここまで追記 ===</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>これで index.html に自動的に追記されるようになります。</p><h5 id="index-html-の抜粋"><a href="#index-html-の抜粋" class="headerlink" title="index.html の抜粋"></a>index.html の抜粋</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- bower:js --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/jquery/dist/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/angular/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/angular-i18n/angular-locale_ja-jp.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- endbower --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="日本語表記に変わったか確かめてみる"><a href="#日本語表記に変わったか確かめてみる" class="headerlink" title="日本語表記に変わったか確かめてみる"></a>日本語表記に変わったか確かめてみる</h2><p>以下のような HTML と JS を用意し、レンダリング結果を見てみます。</p><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"ja"</span> <span class="attr">ng-app</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Format test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-controller</span>=<span class="string">"FormatCtrl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>日付<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;today&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;today | date: 'fullDate'&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>通貨<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;yen&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;yen | currency&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- bower:js --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/jquery/dist/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/angular/angular.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/angular-i18n/angular-locale_ja-jp.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- endbower --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"scripts/main.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="string">'use strict'</span>;</span><br><span class="line">  angular.module(<span class="string">'app'</span>, []).controller(<span class="string">'FormatCtrl'</span>, [<span class="string">'$scope'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">$scope</span>) </span>&#123;</span><br><span class="line">    $scope.today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    $scope.yen = <span class="number">1000000</span>;</span><br><span class="line">  &#125;]);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="結果"><a href="#結果" class="headerlink" title="結果"></a>結果</h3><div style="padding: 0px 15px; border: 1px solid black"><h1>日付</h1><p>“2014-09-15T11:38:50.158Z”</p><p>2014年9月15日月曜日</p><h1>通貨</h1><p>1000000</p><p>\1,000,000</p></div><p>きちんと日本語の表記にフォーマットされていますね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AngularJS-で-currency-フィルタや-date-フィルタを日本語の表記に合わせるには？&quot;&gt;&lt;a href=&quot;#AngularJS-で-currency-フィルタや-date-フィルタを日本語の表記に合わせるには？&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="AngularJS" scheme="https://skatsuta.github.io/tags/AngularJS/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub Pages で簡単ブログ作成</title>
    <link href="https://skatsuta.github.io/2015/04/30/hexo-github-pages/"/>
    <id>https://skatsuta.github.io/2015/04/30/hexo-github-pages/</id>
    <published>2015-04-30T08:34:17.000Z</published>
    <updated>2018-03-13T08:06:37.810Z</updated>
    
    <content type="html"><![CDATA[<p>いまや巷には<a href="https://staticsitegenerators.net/" target="_blank" rel="noopener">溢れるほどの静的サイトジェネレータがあります</a>が、このブログは <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a> を使って書き、 GitHub Pages で公開しています。 個人的に今 Go 言語が好きなこともあって <a href="http://gohugo.io" target="_blank" rel="noopener">Hugo</a> とどちらを使おうかかなり悩んだのですが、僕は（デザインセンスに自信がないので）格好いい出来合いのテーマを使いたかったので、テーマの種類が多い Hexo を選びました。</p><p>Hexo の導入自体は非常に簡単なのですが、 GitHub Pages と連携させる際のやり方が最近ちょっと変わったらしく、検索して出てきた情報がどれも古かったので、覚え書きも兼ねて書いてみます。</p><h2 id="参考サイト"><a href="#参考サイト" class="headerlink" title="参考サイト"></a>参考サイト</h2><p>以下のサイトを参考にさせていただきました。</p><ul><li><a href="http://liginc.co.jp/web/programming/server/104594" target="_blank" rel="noopener">所要時間3分!? Github PagesとHEXOで爆速ブログ構築してみよう！ | 株式会社LIG</a></li><li><a href="http://blog.otakumode.com/2014/08/08/Blogging-with-hexoio/" target="_blank" rel="noopener">チームブログをGitHubとHexoではじめよう！ | Tokyo Otaku Mode Blog</a></li><li><a href="http://qiita.com/bird_nitryn/items/5988a1efe47e0d47132b" target="_blank" rel="noopener">Hexo と GitHub Pages でブログ環境を構築して公開する - Qiita</a></li></ul><p>ただし注意点として、これらの記事はどれも Github Pages で公開する手順の設定情報が古いです。現在の正しい設定は下記「<strong>GitHub Pages で公開する</strong>」のセクションに書きました。</p><h2 id="Hexo-を導入する"><a href="#Hexo-を導入する" class="headerlink" title="Hexo を導入する"></a>Hexo を導入する</h2><p>まず Git と Node がインストールされていることが前提です。これらの導入方法については省略します。</p><p>Hexo の導入自体は<a href="http://hexo.io" target="_blank" rel="noopener">公式サイトのトップページ</a>に載っている通りにコマンドを実行するだけです。が、 Hexo のリソース自体も GitHub などで管理したほうがいいので、先にリポジトリを作った上で、それをクローンしてきて、その中で Hexo の初期化を実行したほうが良いと思います。</p><p>以下は僕の例です。 <a href="https://github.com/skatsuta/blog-hexo" target="_blank" rel="noopener">skatsuta/blog-hexo</a> という GitHub リポジトリを作った上で、以下を実行します。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo をインストールする</span></span><br><span class="line">$ npm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作っておいた Hexo 用のリポジトリをクローンしてくる</span></span><br><span class="line">$ git <span class="built_in">clone</span> git@github.com:skatsuta/blog-hexo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo の初期化を実行する</span></span><br><span class="line"><span class="comment"># (必要なファイル/フォルダが生成されるとともに、.gitignore が上書きされます)</span></span><br><span class="line">$ hexo init blog-hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># リポジトリに移動する</span></span><br><span class="line">$ <span class="built_in">cd</span> blog-hexo</span><br><span class="line"></span><br><span class="line"><span class="comment"># npm モジュールをインストールする</span></span><br><span class="line">$ npm install</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hexo サーバを動かしてプレビューを確認する</span></span><br><span class="line">$ hexo server</span><br><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>メッセージの通り <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> にアクセスしてみて、無事にプレビューが表示されればとりあえずの構築は完了です。</p><h2 id="ファイルの変更をブラウザに即時反映する"><a href="#ファイルの変更をブラウザに即時反映する" class="headerlink" title="ファイルの変更をブラウザに即時反映する"></a>ファイルの変更をブラウザに即時反映する</h2><p>デフォルトでは記事を書き換えてもプレビューには即時反映されず、毎回サーバを再起動しなければなりません。 Markdown エディタで書けばだいたいの仕上がり具合はわかりますが、やはり実際に適用されるテーマとは違ってしまいます。</p><p>そこで <a href="http://www.browsersync.io/" target="_blank" rel="noopener">BrowserSync</a> を使い、プレビューへの即時反映の設定をしてみたいと思います。</p><p>まず <a href="http://www.browsersync.io/#install" target="_blank" rel="noopener">Get started in 5 minutes</a> の <strong>2.</strong> に従い、 BrowserSync をインストールします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g browser-sync</span><br></pre></td></tr></table></figure><p>続いて、 <a href="https://github.com/hexojs/hexo-browsersync" target="_blank" rel="noopener">hexo-browsersync</a> プラグインをインストールします。 <code>package.json</code> にも加えたいので、 <code>--save</code> オプションを付けておきます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-browsersync --save</span><br></pre></td></tr></table></figure><p>これで導入は終わりです。再び Hexo サーバを立ち上げてから設定や記事を書き換えて保存すると、そのたびに以下のようなメッセージが出てブラウザがリロードされ、変更点がプレビューに即時に反映されるはずです。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">INFO  Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line">[BS] Reloading Browsers...</span><br><span class="line">[BS] Reloading Browsers...</span><br><span class="line">[BS] Reloading Browsers...</span><br></pre></td></tr></table></figure><h2 id="記事を書く"><a href="#記事を書く" class="headerlink" title="記事を書く"></a>記事を書く</h2><p>快適な執筆環境が整ったところで、早速記事を書いていきます。 Hexo で新しく記事を作るには以下のコマンドを実行します。たとえば <code>Hello, World</code> というタイトルの記事を書く場合です。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"Hello, World"</span></span><br><span class="line">INFO  Created: ~/repos/blog-hexo/<span class="built_in">source</span>/_posts/Hello-World.md</span><br></pre></td></tr></table></figure><p>生成された Markdown ファイルの中は次のようになっています。</p><h5 id="source-posts-Hello-World-md"><a href="#source-posts-Hello-World-md" class="headerlink" title="source/_posts/Hello-World.md"></a>source/_posts/Hello-World.md</h5><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: "Hello, World"</span><br><span class="line">date: 2015-04-30 17:03:08</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>あとは Markdown で好きなように記事を書いていきます。 BrowserSync を入れているとそのありがたみがわかりますよね？</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>日本語で書く場合たいていタイトルも日本語になると思うので、 <code>hexo new &quot;日本語タイトル&quot;</code> というようにコマンド発行したいところです。しかしそうするとファイル名も日本語になってしまい、 Git での管理時にちょっと面倒なことが生じる場合が多いです。なので、ファイル名は英語で生成しておいて、 <code>title:</code> 部分を日本語に書き換えるほうが吉です。このあたりがちょっとした不満点ですね。</p><h2 id="GitHub-Pages-で公開する"><a href="#GitHub-Pages-で公開する" class="headerlink" title="GitHub Pages で公開する"></a>GitHub Pages で公開する</h2><p>最後に GitHub Pages で公開します。</p><p><a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Hexo の Deployment のページ</a>にある通り、まず <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a> プラグインをインストールします。これも <code>package.json</code> に加えたいので、 <code>--save</code> オプションを付けておきます。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>続いて <code>_config.yml</code> の <code>deploy</code> の項目に必要な設定を追記します。以下は僕の例です。 </p><h5 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:skatsuta/skatsuta.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>GitHub Pages で公開する場合には、<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages のドキュメント</a>にもある通り、 <code>&lt;username&gt;.github.io</code> というリポジトリを作ります。そこにプッシュされたコンテンツが自動的に <code>http://&lt;username&gt;.github.io/</code> で公開されるようになります。</p><p>最後に、 Hexo で以下のコマンドを使ってデプロイします。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure><p>上記のコマンドは以下と同じ意味になります。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 静的コンテンツを生成する</span></span><br><span class="line">$ hexo generate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静的コンテンツを設定されたデプロイ先にデプロイする</span></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>実際には、デプロイの際にいったん既存の生成データをすべて削除した上で再生成したほうが良さそうなため、僕は次のようなシェルスクリプトを実行しています。 <code>hexo clean</code> は生成コンテンツとキャッシュをすべて削除するコマンドです。</p><h5 id="deploy-sh"><a href="#deploy-sh" class="headerlink" title="deploy.sh"></a>deploy.sh</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">hexo clean &amp;&amp; hexo deploy --generate</span><br></pre></td></tr></table></figure><p>以上が完了すると、 <a href="http://skatsuta.github.io/">http://skatsuta.github.io/</a> にこのブログが公開されます。</p><h2 id="ね、簡単でしょう？"><a href="#ね、簡単でしょう？" class="headerlink" title="ね、簡単でしょう？"></a>ね、簡単でしょう？</h2><p>Hexo は記事をすべて Markdown で書けるので簡単にバージョン管理ができますし、他の Markdown 対応静的サイトジェネレータに移行するのもハードルが低いです。</p><p>ちなみにこのブログのテーマには <a href="https://github.com/xiangming/landscape-plus" target="_blank" rel="noopener">Landscape plus</a> を少しカスタムして使っています。デフォルトで結構格好いいので気に入っています。</p><p>当分の間は Hexo をいろいろいじりながら使ってみようと思います。 Hugo がもう少し成熟したらそちらも使ってみたいですね。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;いまや巷には&lt;a href=&quot;https://staticsitegenerators.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;溢れるほどの静的サイトジェネレータがあります&lt;/a&gt;が、このブログは &lt;a href=&quot;http://hexo.
      
    
    </summary>
    
    
      <category term="Hexo" scheme="https://skatsuta.github.io/tags/Hexo/"/>
    
      <category term="GitHub Pages" scheme="https://skatsuta.github.io/tags/GitHub-Pages/"/>
    
  </entry>
  
  <entry>
    <title>シェルスクリプトの覚え書き</title>
    <link href="https://skatsuta.github.io/2015/04/29/shell-script/"/>
    <id>https://skatsuta.github.io/2015/04/29/shell-script/</id>
    <published>2015-04-29T12:21:49.000Z</published>
    <updated>2018-03-13T08:06:37.811Z</updated>
    
    <content type="html"><![CDATA[<p>たまにしか書かないのでいつも忘れてしまい、書く必要があるときになって毎度調べ直しているので、覚え書きとしてきちんとまとめてみます。</p><p>内容は非常に初歩的なことばかりです。</p><h2 id="shebang"><a href="#shebang" class="headerlink" title="shebang"></a>shebang</h2><p>シェルスクリプトの先頭に書く宣言文。<br>どのシェルを利用して実行するかを指定する。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br></pre></td></tr></table></figure><h2 id="変数"><a href="#変数" class="headerlink" title="変数"></a>変数</h2><h3 id="シェル変数"><a href="#シェル変数" class="headerlink" title="シェル変数"></a>シェル変数</h3><p>実行しているシェルの内部でのみ有効な変数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 変数abcに123を代入する</span></span><br><span class="line">abc=123</span><br></pre></td></tr></table></figure><h3 id="環境変数"><a href="#環境変数" class="headerlink" title="環境変数"></a>環境変数</h3><p>シェルから実行されたコマンド内でも有効な変数。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 環境変数abcを設定する</span></span><br><span class="line"><span class="built_in">export</span> abc=123</span><br></pre></td></tr></table></figure><h2 id="read-コマンド"><a href="#read-コマンド" class="headerlink" title="read コマンド"></a><code>read</code> コマンド</h2><p>標準入力からデータを読み込む。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># abc に標準出力からのデータを代入する</span></span><br><span class="line"><span class="built_in">read</span> abc</span><br></pre></td></tr></table></figure><h2 id="引用符"><a href="#引用符" class="headerlink" title="引用符"></a>引用符</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 変数 abc に文字列 xyz をセットする</span></span><br><span class="line">$ abc=xyz</span><br><span class="line"></span><br><span class="line"><span class="comment"># シングルクォーテーションは文字列として認識する</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'The value of abc is $abc.'</span></span><br><span class="line">The value of abc is <span class="variable">$abc</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># ダブルクォーテーションは変数として展開する</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"The value of abc is <span class="variable">$abc</span>."</span></span><br><span class="line">The value of abc is xyz.</span><br><span class="line"></span><br><span class="line"><span class="comment"># バッククオートはコマンドとして実行する</span></span><br><span class="line">$ abc=`date`</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$abc</span></span><br><span class="line">2014年 7月 15日 火曜日 17:56:34 JST</span><br></pre></td></tr></table></figure><h2 id="引数"><a href="#引数" class="headerlink" title="引数"></a>引数</h2><p><code>$0</code>は実行コマンド名、<code>$#</code>は引数の数を表す。</p><h3 id="args-sh"><a href="#args-sh" class="headerlink" title="args.sh"></a>args.sh</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$1: '</span> <span class="variable">$1</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$2: '</span> <span class="variable">$2</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$0: '</span> <span class="variable">$0</span>;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">'$#: '</span> <span class="variable">$#</span>;</span><br></pre></td></tr></table></figure><h3 id="実行結果"><a href="#実行結果" class="headerlink" title="実行結果"></a>実行結果</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./args.sh aaa bbb</span><br><span class="line"><span class="variable">$1</span>: aaa</span><br><span class="line"><span class="variable">$2</span>: bbb</span><br><span class="line"><span class="variable">$0</span>: ./args.sh</span><br><span class="line"><span class="variable">$#</span>: 2</span><br></pre></td></tr></table></figure><h2 id="エスケープシーケンス"><a href="#エスケープシーケンス" class="headerlink" title="エスケープシーケンス"></a>エスケープシーケンス</h2><p>行末にバックスラッシュをつけると、<strong>改行コードがエスケープ</strong>されて文字列を途中で折り返すことができる。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"Hi! \</span></span><br><span class="line"><span class="string">Today is the day!"</span></span><br><span class="line">Hi! Today is the day!</span><br></pre></td></tr></table></figure><h2 id="条件分岐"><a href="#条件分岐" class="headerlink" title="条件分岐"></a>条件分岐</h2><h3 id="構文"><a href="#構文" class="headerlink" title="構文"></a>構文</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">elif</span> [ condition2 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h2 id="演算子"><a href="#演算子" class="headerlink" title="演算子"></a>演算子</h2><h3 id="文字列比較"><a href="#文字列比較" class="headerlink" title="文字列比較"></a>文字列比較</h3><table><thead><tr><th>演算子</th><th>比較内容</th></tr></thead><tbody><tr><td><code>a == b</code></td><td>a と b が等しければ真</td></tr><tr><td><code>a != b</code></td><td>a と b が等しくなければ真</td></tr></tbody></table><h3 id="数値比較"><a href="#数値比較" class="headerlink" title="数値比較"></a>数値比較</h3><table><thead><tr><th>演算子</th><th>比較内容</th></tr></thead><tbody><tr><td><code>a -eq b</code></td><td>a と b が等しければ真</td></tr><tr><td><code>a -ne b</code></td><td>a と b が等しくなければ真</td></tr><tr><td><code>a -ge b</code></td><td>a が b 以上なら真</td></tr><tr><td><code>a -le b</code></td><td>a が b 以下なら真</td></tr><tr><td><code>a -gt b</code></td><td>a が b より大きいなら真</td></tr><tr><td><code>a -lt b</code></td><td>a が b より小さいなら真</td></tr></tbody></table><h2 id="ファイル属性の確認"><a href="#ファイル属性の確認" class="headerlink" title="ファイル属性の確認"></a>ファイル属性の確認</h2><p>パスがディレクトリであれば真</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -d path ]; <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure><h3 id="test-コマンドの書き方2通り"><a href="#test-コマンドの書き方2通り" class="headerlink" title="test コマンドの書き方2通り"></a>test コマンドの書き方2通り</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> 条件節; <span class="keyword">then</span> ...</span><br><span class="line"><span class="keyword">if</span> [ 条件節 ]; <span class="keyword">then</span> ...</span><br></pre></td></tr></table></figure><h3 id="ファイル属性を確認する演算子"><a href="#ファイル属性を確認する演算子" class="headerlink" title="ファイル属性を確認する演算子"></a>ファイル属性を確認する演算子</h3><table><thead><tr><th>演算子</th><th>内容</th></tr></thead><tbody><tr><td><code>-f ファイル名</code></td><td>通常ファイルなら真</td></tr><tr><td><code>-d ファイル名</code></td><td>ディレクトリなら真</td></tr><tr><td><code>-e ファイル名</code></td><td>ファイルが存在すれば真</td></tr><tr><td><code>-L ファイル名</code></td><td>シンボリックリンクなら真</td></tr><tr><td><code>-r ファイル名</code></td><td>読み取り可能なら真</td></tr><tr><td><code>-w ファイル名</code></td><td>書き込み可能なら真</td></tr><tr><td><code>-x ファイル名</code></td><td>ファイルに実行権限があれば真</td></tr><tr><td><code>-s ファイル名</code></td><td>サイズが0より大きければ真</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;たまにしか書かないのでいつも忘れてしまい、書く必要があるときになって毎度調べ直しているので、覚え書きとしてきちんとまとめてみます。&lt;/p&gt;
&lt;p&gt;内容は非常に初歩的なことばかりです。&lt;/p&gt;
&lt;h2 id=&quot;shebang&quot;&gt;&lt;a href=&quot;#shebang&quot; class
      
    
    </summary>
    
    
      <category term="shell script" scheme="https://skatsuta.github.io/tags/shell-script/"/>
    
  </entry>
  
</feed>
